<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>ğŸ¯ ëœë¤ ë“œë¡­ ì„œë°”ì´ë²Œ</title>
  <style>
    :root { --r: 16px; }
    body{
      margin:0; background:#0b0f14; color:#e9eef6;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif;
      -webkit-tap-highlight-color: transparent;
    }
    .wrap{max-width:980px;margin:0 auto;padding:14px;}
    .card{
      background:#111826;border:1px solid #223049;border-radius:var(--r);
      padding:12px; box-shadow:0 8px 22px rgba(0,0,0,.35);
    }
    h1{font-size:18px;margin:0 0 8px;}
    .muted{color:#a9b6cc;font-size:13px;line-height:1.35}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:8px}
    input,textarea,select,button{
      border:1px solid #2a3a57;background:#0e1522;color:#e9eef6;
      border-radius:12px;padding:10px 12px;font-size:14px;outline:none;
    }
    textarea{width:100%;resize:vertical;min-height:86px}
    button{cursor:pointer;background:#1a2a46}
    button.primary{background:#2d5bff;border-color:#2d5bff}
    button.danger{background:#ff3b3b;border-color:#ff3b3b;color:#fff}
    button:disabled{opacity:.55;cursor:not-allowed}
    .pill{display:inline-flex;gap:8px;align-items:center;border:1px solid #2a3a57;padding:8px 10px;border-radius:999px;background:#0e1522}
    canvas{
      width:100%; height:auto; display:block;
      border-radius:14px; border:1px solid #223049; background:#0e1522;
      touch-action: manipulation;
    }
    .big{font-size:22px;font-weight:800}
    .center{text-align:center}
    .sep{height:1px;background:#223049;margin:10px 0}
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>ğŸ¯ ëœë¤ ë“œë¡­ ì„œë°”ì´ë²Œ (Plinko)</h1>
    <div class="muted">
      ì´ë¦„ ë„£ê³  <b>DROP</b> ëˆ„ë¥´ë©´ ê³µì´ í•€ì— íŠ•ê¸°ë©° ë‚´ë ¤ì™€ì„œ <b>ëœë¤ìœ¼ë¡œ í•œ ëª…</b>ì—ê²Œ ë–¨ì–´ì§ â†’ ê·¸ ì‚¬ëŒì´ íŒ¨ë°°(ë‚´ê¸°/ë²Œì¹™).<br/>
      í•€ë³¼ì²˜ëŸ¼ â€œë§ˆì§€ë§‰ì— ë”± ê±¸ë¦¬ëŠ”â€ ë§›ì´ ìˆìŒ ğŸ˜ˆ
    </div>

    <div class="row">
      <textarea id="names" placeholder="ì´ë¦„ì„ ì¤„ë°”ê¿ˆìœ¼ë¡œ ì…ë ¥ (ìµœëŒ€ 10ëª…)
ì˜ˆ: ì‹ ì˜
ì™€ì´í”„
ì² ìˆ˜
ì˜í¬"></textarea>
    </div>

    <div class="row">
      <span class="pill">ê³µ ê°œìˆ˜
        <select id="ballCount">
          <option value="1" selected>1ê°œ (ê¸°ë³¸)</option>
          <option value="2">2ê°œ (ë” ë°•ì§„ê°)</option>
          <option value="3">3ê°œ (ë‚œì¥íŒ)</option>
        </select>
      </span>

      <span class="pill">í•€ ë°€ë„
        <select id="pinDensity">
          <option value="low">ë‚®ìŒ</option>
          <option value="mid" selected>ë³´í†µ</option>
          <option value="high">ë†’ìŒ</option>
        </select>
      </span>

      <span class="pill">ê²°ê³¼ ê·œì¹™
        <select id="rule">
          <option value="lose" selected>ë§ì€ ì‚¬ëŒ íŒ¨ë°°</option>
          <option value="win">ë§ì€ ì‚¬ëŒ ë‹¹ì²¨</option>
        </select>
      </span>
    </div>

    <div class="row">
      <button class="primary" id="startBtn">ë³´ë“œ ì¤€ë¹„</button>
      <button class="primary" id="dropBtn" disabled>DROP ğŸ±</button>
      <button id="shakeBtn" disabled>í”ë“¤ê¸°(ë‚œìˆ˜â†‘)</button>
      <button class="danger" id="resetBtn">ë¦¬ì…‹</button>
      <span class="muted" id="msg"></span>
    </div>

    <div class="sep"></div>

    <canvas id="cv" width="900" height="1200"></canvas>

    <div class="sep"></div>
    <div class="center">
      <div class="muted">ê²°ê³¼</div>
      <div class="big" id="result">-</div>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);

  // crypto random
  function rand01(){
    const u = new Uint32Array(1);
    crypto.getRandomValues(u);
    return u[0] / 0xFFFFFFFF;
  }
  function randInt(min, maxInclusive){
    return min + Math.floor(rand01() * (maxInclusive - min + 1));
  }
  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j = randInt(0,i);
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }

  const cv = $("cv");
  const ctx = cv.getContext("2d");

  // board state
  let names = [];
  let slots = [];
  let pins = [];
  let balls = [];
  let running = false;
  let ready = false;
  let gravity = 0.22;
  let restitution = 0.78; // bounciness
  let friction = 0.998;
  let air = 0.999;
  let shakeVX = 0;

  // geometry
  const W = cv.width, H = cv.height;
  const topMargin = 90;
  const side = 40;
  const bottomH = 170;

  function parseNames(){
    const raw = $("names").value.split("\n").map(s=>s.trim()).filter(Boolean);
    const seen = new Set();
    const out = [];
    for(const n of raw){
      if(!seen.has(n)){ seen.add(n); out.push(n); }
    }
    return out.slice(0,10);
  }

  function setMsg(t){ $("msg").textContent = t || ""; }
  function setResult(t){ $("result").textContent = t || "-"; }

  function buildBoard(){
    names = parseNames();
    if(names.length < 3){
      setMsg("ìµœì†Œ 3ëª…ë¶€í„° ê°€ëŠ¥!");
      return;
    }
    setMsg("");
    setResult("-");

    // slots
    slots = [];
    const n = names.length;
    const slotW = (W - side*2) / n;
    for(let i=0;i<n;i++){
      slots.push({
        i,
        name: names[i],
        x0: side + i*slotW,
        x1: side + (i+1)*slotW
      });
    }

    // pins
    pins = [];
    const density = $("pinDensity").value; // low/mid/high
    const gapY = density==="low" ? 95 : density==="high" ? 62 : 78;
    const gapX = density==="low" ? 95 : density==="high" ? 62 : 78;
    const pinR = density==="high" ? 10 : density==="low" ? 12 : 11;

    const startY = topMargin + 70;
    const endY = H - bottomH - 60;

    let row = 0;
    for(let y = startY; y <= endY; y += gapY){
      const offset = (row % 2) ? gapX/2 : 0;
      for(let x = side + 40 + offset; x <= W - side - 40; x += gapX){
        // slight jitter to avoid symmetry
        const jx = (rand01()-0.5) * 10;
        const jy = (rand01()-0.5) * 6;
        pins.push({ x: x + jx, y: y + jy, r: pinR });
      }
      row++;
    }

    // balls reset
    balls = [];
    running = false;
    ready = true;
    $("dropBtn").disabled = false;
    $("shakeBtn").disabled = false;
    draw();
  }

  function spawnBalls(){
    if(!ready || running) return;
    setResult("-");
    setMsg("");
    const k = Number($("ballCount").value);
    balls = [];
    running = true;

    // spawn near top center with slight spread
    for(let i=0;i<k;i++){
      const r = 16;
      const x = W/2 + (i-(k-1)/2)*36 + (rand01()-0.5)*18;
      const y = topMargin;
      balls.push({
        x, y, r,
        vx: (rand01()-0.5)*2.2,
        vy: 0,
        done: false,
        landedSlot: null
      });
    }
  }

  function applyShake(){
    // transient wind left/right
    shakeVX = (rand01() < 0.5 ? -1 : 1) * (2.2 + rand01()*2.2);
    setMsg("ë³´ë“œ í”ë“¤ë¦¼! ã…‹ã…‹");
    setTimeout(()=>{ shakeVX = 0; setMsg(""); }, 500);
  }

  function circleCollision(ball, pin){
    const dx = ball.x - pin.x;
    const dy = ball.y - pin.y;
    const dist = Math.hypot(dx, dy);
    const minDist = ball.r + pin.r;
    if(dist < minDist && dist > 0.0001){
      // push out
      const nx = dx / dist;
      const ny = dy / dist;
      const overlap = (minDist - dist);

      ball.x += nx * overlap;
      ball.y += ny * overlap;

      // reflect velocity (simple elastic)
      const vn = ball.vx*nx + ball.vy*ny;
      if(vn < 0){
        ball.vx -= (1 + restitution) * vn * nx;
        ball.vy -= (1 + restitution) * vn * ny;
      }

      // add slight randomness to avoid deterministic loops
      ball.vx += (rand01()-0.5)*0.25;
      ball.vy += (rand01()-0.5)*0.12;
    }
  }

  function wallCollision(ball){
    // left/right walls
    if(ball.x - ball.r < side){
      ball.x = side + ball.r;
      ball.vx = Math.abs(ball.vx) * restitution;
    }
    if(ball.x + ball.r > W - side){
      ball.x = W - side - ball.r;
      ball.vx = -Math.abs(ball.vx) * restitution;
    }
    // ceiling
    if(ball.y - ball.r < 20){
      ball.y = 20 + ball.r;
      ball.vy = Math.abs(ball.vy) * restitution;
    }
  }

  function checkLanding(ball){
    const yFloor = H - bottomH + 20;
    if(ball.y + ball.r >= yFloor){
      // determine slot by x
      const s = slots.find(sl => ball.x >= sl.x0 && ball.x < sl.x1) || slots[slots.length-1];
      ball.done = true;
      ball.landedSlot = s;

      // snap for nice look
      ball.y = yFloor - ball.r;
      ball.vx = 0; ball.vy = 0;
    }
  }

  function step(){
    if(!running){
      draw();
      requestAnimationFrame(step);
      return;
    }

    for(const b of balls){
      if(b.done) continue;

      // physics
      b.vy += gravity;
      b.vx += shakeVX * 0.03;

      b.x += b.vx;
      b.y += b.vy;

      b.vx *= friction;
      b.vy *= air;

      wallCollision(b);

      // collide with pins
      for(const p of pins){
        circleCollision(b,p);
      }

      checkLanding(b);
    }

    // all landed?
    if(balls.length && balls.every(b => b.done)){
      running = false;
      finalizeResult();
    }

    draw();
    requestAnimationFrame(step);
  }

  function finalizeResult(){
    // if multiple balls: choose "worst luck" = random among landed slots? (more fun: pick first ball landed)
    // We'll do: pick the ball that landed LAST (most suspense) -> last in time, but we didn't record time.
    // Alternative: pick random among landed slots for fairness. Let's do: random among balls' landed slots.
    const picked = balls[randInt(0, balls.length-1)].landedSlot;
    const rule = $("rule").value;

    const text = (rule === "lose")
      ? `ğŸ’¥ ${picked.name} íŒ¨ë°°! (ë§ìŒ)`
      : `ğŸ‰ ${picked.name} ë‹¹ì²¨! (ë§ìŒ)`;

    setResult(text);

    // small shake celebration
    applyMiniFlash();
  }

  function applyMiniFlash(){
    let t = 0;
    const id = setInterval(()=>{
      t++;
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0,0,W,H);
      ctx.restore();
      if(t>=6) clearInterval(id);
    }, 60);
  }

  function draw(){
    // background
    ctx.clearRect(0,0,W,H);

    // title area
    ctx.save();
    ctx.fillStyle = "#0e1522";
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    // playfield frame
    ctx.save();
    ctx.strokeStyle = "#223049";
    ctx.lineWidth = 4;
    roundRect(ctx, side-10, 20, W - (side-10)*2, H-40, 18);
    ctx.stroke();
    ctx.restore();

    // top funnel
    ctx.save();
    ctx.strokeStyle = "#2a3a57";
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(W/2 - 140, topMargin);
    ctx.lineTo(W/2 - 40, 20);
    ctx.moveTo(W/2 + 140, topMargin);
    ctx.lineTo(W/2 + 40, 20);
    ctx.stroke();
    ctx.restore();

    // pins
    ctx.save();
    ctx.fillStyle = "#cfe3ff";
    for(const p of pins){
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // bottom slots area
    const yTop = H - bottomH;
    ctx.save();
    ctx.fillStyle = "#0b0f14";
    ctx.fillRect(0, yTop, W, bottomH);
    ctx.restore();

    // slot dividers + names
    ctx.save();
    ctx.strokeStyle = "#223049";
    ctx.lineWidth = 3;
    ctx.fillStyle = "#e9eef6";
    ctx.font = "24px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    for(let i=0;i<slots.length;i++){
      const sl = slots[i];
      ctx.beginPath();
      ctx.moveTo(sl.x0, yTop);
      ctx.lineTo(sl.x0, H-20);
      ctx.stroke();

      // name
      const cx = (sl.x0 + sl.x1) / 2;
      const cy = yTop + 90;
      // small pill behind name
      drawNamePill(cx, cy, sl.name);
    }
    // last divider
    const last = slots[slots.length-1];
    ctx.beginPath();
    ctx.moveTo(last.x1, yTop);
    ctx.lineTo(last.x1, H-20);
    ctx.stroke();

    ctx.restore();

    // balls
    ctx.save();
    for(const b of balls){
      ctx.beginPath();
      ctx.fillStyle = b.done ? "#2d5bff" : "#ffffff";
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();

      // highlight
      ctx.globalAlpha = 0.25;
      ctx.beginPath();
      ctx.fillStyle = "#ffffff";
      ctx.arc(b.x - 6, b.y - 7, b.r*0.55, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    ctx.restore();

    // hint if not ready
    if(!ready){
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "#e9eef6";
      ctx.font = "34px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("ì´ë¦„ ì…ë ¥ â†’ ë³´ë“œ ì¤€ë¹„", W/2, H/2);
      ctx.restore();
    } else if(!running && balls.length===0){
      ctx.save();
      ctx.fillStyle = "#a9b6cc";
      ctx.font = "26px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("DROPì„ ëˆŒëŸ¬ ì‹œì‘!", W/2, topMargin + 40);
      ctx.restore();
    }
  }

  function drawNamePill(cx, cy, text){
    ctx.save();
    const padX = 18;
    const padY = 12;
    // measure
    const w = ctx.measureText(text).width + padX*2;
    const h = 44;
    ctx.fillStyle = "#0e1522";
    ctx.strokeStyle = "#2a3a57";
    ctx.lineWidth = 2;
    roundRect(ctx, cx - w/2, cy - h/2, w, h, 999);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = "#e9eef6";
    ctx.fillText(text, cx, cy+1);
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  // buttons
  $("startBtn").addEventListener("click", () => {
    buildBoard();
  });

  $("dropBtn").addEventListener("click", () => {
    if(!ready) return;
    if(running) return;
    spawnBalls();
  });

  $("shakeBtn").addEventListener("click", () => {
    if(!ready) return;
    applyShake();
  });

  $("resetBtn").addEventListener("click", () => {
    names = [];
    slots = [];
    pins = [];
    balls = [];
    running = false;
    ready = false;
    $("dropBtn").disabled = true;
    $("shakeBtn").disabled = true;
    setMsg("");
    setResult("-");
    draw();
  });

  // start loop
  draw();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
