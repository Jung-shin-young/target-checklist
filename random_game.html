<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Marble Roulette Style â€” Chaos Drop Royale</title>
  <style>
    html,body{margin:0;height:100%;background:#05060b;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto}
    canvas{display:block}

    #panel{
      position:fixed;left:14px;top:14px;z-index:20;
      width:min(460px, calc(100vw - 28px));
      background:rgba(10,12,20,.82);
      border:1px solid rgba(255,255,255,.14);
      border-radius:16px;
      box-shadow:0 10px 40px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }
    #panel header{
      display:flex;align-items:center;justify-content:space-between;
      padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.10);
    }
    #panel header .title{font-weight:800;font-size:13px;letter-spacing:.2px}
    #panel header .sub{font-size:11px;opacity:.75;margin-left:8px}
    #panel header .right{display:flex;gap:8px;align-items:center}
    #panel button{
      padding:7px 10px;border-radius:12px;border:1px solid rgba(255,255,255,.16);
      background:rgba(20,26,44,.9);color:#fff;cursor:pointer;font-weight:700
    }
    #panel button:hover{filter:brightness(1.1)}
    #body{padding:12px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .box{
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;padding:10px;background:rgba(255,255,255,.03)
    }
    .box h3{margin:0 0 8px 0;font-size:12px;opacity:.9}
    textarea{
      width:100%;min-height:88px;resize:vertical;
      padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,.14);
      background:#0b0f1f;color:#fff;font-size:12px;line-height:1.4
    }
    label{display:flex;gap:8px;align-items:center;font-size:12px;opacity:.9;margin:6px 0}
    input[type="number"]{
      width:86px;padding:6px 8px;border-radius:10px;border:1px solid rgba(255,255,255,.14);
      background:#0b0f1f;color:#fff
    }
    input[type="checkbox"]{transform:scale(1.1)}
    #hud{
      margin-top:10px;
      padding:10px;border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.25);
      font-size:12px;line-height:1.5;opacity:.92
    }
    #mini{
      position:fixed;left:14px;top:14px;z-index:21;display:none;
      padding:10px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.14);
      background:rgba(10,12,20,.82);backdrop-filter: blur(10px);
      box-shadow:0 10px 40px rgba(0,0,0,.45);
    }
    #mini .row{display:flex;gap:8px;align-items:center}
    #mini .txt{font-size:12px;font-weight:800}
    #mini .sub{font-size:11px;opacity:.7}
  </style>
</head>
<body>
  <div id="mini">
    <div class="row">
      <div>
        <div class="txt">ğŸ° Marble Drop</div>
        <div class="sub" id="miniHud">ëŒ€ê¸°ì¤‘</div>
      </div>
      <button id="openBtn">ì—´ê¸°</button>
      <button id="startBtn2">ì‹œì‘</button>
    </div>
  </div>

  <div id="panel">
    <header>
      <div>
        <span class="title">ğŸ° Marble Roulette Style</span>
        <span class="sub">ì„¸ë¡œ ë‚™í•˜í˜• + ì¥ì• ë¬¼ + â€œì ë‹¹ ë°˜ì „â€</span>
      </div>
      <div class="right">
        <button id="toggleBtn">ì ‘ê¸°</button>
        <button id="startBtn">START</button>
        <button id="seedBtn">SEED</button>
      </div>
    </header>

    <div id="body">
      <div class="grid">
        <div class="box">
          <h3>ì´ë¦„ ì…ë ¥ (ì½¤ë§ˆ/ì¤„ë°”ê¿ˆ OK, ê°€ì¤‘ì¹˜ *N ê°€ëŠ¥)</h3>
          <textarea id="names">ì§±êµ¬*5, ì§±ì•„*10, ë´‰ë¯¸ì„ *3</textarea>
          <div style="font-size:11px;opacity:.7;margin-top:6px">
            ì˜ˆ: A*3, B*1 ë˜ëŠ” ì¤„ë°”ê¿ˆìœ¼ë¡œë„ ê°€ëŠ¥
          </div>
        </div>

        <div class="box">
          <h3>ì˜µì…˜</h3>
          <label>ìµœëŒ€ ì¸ì›(2~20) <input id="maxPlayers" type="number" min="2" max="20" value="20"></label>
          <label>ìµœëŒ€ ê³µ/ì¸(1~3) <input id="maxBalls" type="number" min="1" max="3" value="2"></label>
          <label>í˜¼ëˆ ë ˆë²¨(0~5) <input id="chaos" type="number" min="0" max="5" value="3"></label>
          <label>ì‹œë“œ <input id="seed" type="number" min="1" max="999999" value="12345"></label>

          <label><input id="rndPlayers" type="checkbox" checked> ì¸ì› ëœë¤(ì…ë ¥ì—ì„œ ì¼ë¶€ë§Œ ë½‘ìŒ)</label>
          <label><input id="rndBalls" type="checkbox" checked> ê³µ ìˆ˜ ëœë¤</label>
          <label><input id="rndSize" type="checkbox" checked> í¬ê¸°/ë¬´ê²Œ ëœë¤</label>
          <label><input id="showNames" type="checkbox" checked> ì´ë¦„ í‘œì‹œ</label>
        </div>
      </div>

      <div id="hud">ëŒ€ê¸°ì¤‘â€¦</div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
  <script>
    // ----- deterministic RNG -----
    function mulberry32(a){
      return function(){
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      }
    }
    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));

    // ----- parse names: comma/newline, allow *N -----
    function parseNames(raw){
      const parts = raw
        .replace(/\r/g,'')
        .split(/[\n,]+/)
        .map(s=>s.trim())
        .filter(Boolean);

      const out = [];
      for(const p of parts){
        const m = p.match(/^(.+?)\s*\*\s*(\d+)$/);
        if (m){
          const name = m[1].trim();
          const n = clamp(parseInt(m[2],10)||1,1,999);
          for(let i=0;i<n;i++) out.push(name);
        } else {
          out.push(p);
        }
      }
      return out.slice(0, 200); // safety
    }

    // ----- game dims -----
    const W = 760;
    const VIEW_H = 920;
    const WORLD_H = 5600;
    const WALL = 26;

    const Z1 = {y0: 140,  y1: 1700};
    const Z2 = {y0: 1700, y1: 3200};
    const Z3 = {y0: 3200, y1: 4200};
    const Z4 = {y0: 4200, y1: 5000};
    const ZF = {y0: 5000, y1: 5480};

    class Main extends Phaser.Scene {
      constructor(){ super('main'); }
      init(data){
        this.cfg = data.cfg;
        this.rng = mulberry32(this.cfg.seed|0);
        this.balls = [];
        this.labels = [];
        this.total = 0;
        this.finished = 0;
        this.startAt = 0;
        this.finalEventFired = false;
        this.gravityEventDone = false;
      }

      create(){
        // physics tuning: punchy collisions
        this.matter.world.setBounds(0,0,W,WORLD_H,64,true,true,false,true);
        this.matter.world.engine.positionIterations = 10;
        this.matter.world.engine.velocityIterations = 8;
        this.matter.world.setGravity(0, 1.12);

        // camera
        this.cameras.main.setBounds(0,0,W,WORLD_H);
        this.cameras.main.setViewport(0,0,window.innerWidth,window.innerHeight);
        this.cameras.main.setZoom(1.12);

        this.scale.on('resize', (gs)=>{
          this.cameras.main.setViewport(0,0,gs.width,gs.height);
        });

        // neon background + track glow
        this._drawNeonBG();
        this._buildTrack();
        this._spawn();

        // finish sensor
        this.finish = this.matter.add.rectangle(W/2, WORLD_H-90, W-2*WALL-70, 18, {isStatic:true,isSensor:true,label:'finish'});
        this._neonRect(W/2, WORLD_H-90, W-2*WALL-70, 18, 0x2cff9a, 0.20, 2.2);

        this.matter.world.on('collisionstart', (evt)=>{
          for (const pair of evt.pairs){
            const a=pair.bodyA, b=pair.bodyB;
            if ((a.label==='finish' && b.label==='ball') || (b.label==='finish' && a.label==='ball')){
              const ball = (a.label==='ball') ? a : b;
              const go = ball.gameObject;
              if (go && !go._done){
                go._done = true;
                this.finished++;
                go.setStatic(true);
                this.tweens.add({targets:go, alpha:0.25, duration:220});
              }
            }
          }
        });

        this.startAt = performance.now();

        // HUD timer
        this.time.addEvent({delay:120, loop:true, callback:()=>this._updateHUD()});

        // events: keep â€œì ë‹¹ ë°˜ì „â€
        this.time.addEvent({
          delay:250, loop:true, callback:()=>{
            const t = (performance.now()-this.startAt)/1000;

            // FINAL once after ~55s if someone near final zone
            if (!this.finalEventFired && t>55){
              const near = this.balls.some(s=>!s._done && s.y > ZF.y0-240);
              if (near) this._finalEvent();
            }

            // optional gravity wiggle (rare)
            if (!this.gravityEventDone && t>46){
              this.gravityEventDone = true;
              if (this.rng() < 0.22){
                const dir = this.rng()<0.5 ? -1 : 1;
                this._announce('EVENT: ì¤‘ë ¥ í”ë“¤ë¦¼');
                this.matter.world.setGravity(0.55*dir, 0.92);
                this.time.delayedCall(1800, ()=> this.matter.world.setGravity(0,1.12));
              }
            }
          }
        });
      }

      update(){
        // follow average alive y (stable + watchable)
        let sum=0,n=0;
        for(const s of this.balls){ if(!s._done){sum+=s.y;n++;} }
        if(n){
          const avg = sum/n;
          const target = clamp(avg - VIEW_H*0.38, 0, WORLD_H - VIEW_H);
          this.cameras.main.scrollY = Phaser.Math.Linear(this.cameras.main.scrollY, target, 0.09);
        }

        // labels follow
        if (this.cfg.showNames){
          for(let i=0;i<this.balls.length;i++){
            const s=this.balls[i], t=this.labels[i];
            if(!t) continue;
            t.setPosition(s.x, s.y - s.displayHeight*0.8);
            t.setVisible(!s._done);
          }
        }
      }

      // ----- visuals helpers -----
      _drawNeonBG(){
        const g = this.add.graphics().setDepth(-20);
        // faint grid
        g.lineStyle(1, 0x1f284a, 0.35);
        for(let y=0;y<=WORLD_H;y+=90){ g.beginPath(); g.moveTo(0,y); g.lineTo(W,y); g.strokePath(); }
        for(let x=0;x<=W;x+=90){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,WORLD_H); g.strokePath(); }
      }

      _neonRect(x,y,w,h,color,fillAlpha=0.08, glow=2.0, angle=0){
        const r = this.add.rectangle(x,y,w,h,color,fillAlpha).setDepth(-5);
        r.setRotation(angle);
        r.setStrokeStyle(3, color, 0.85);
        // extra glow strokes
        const g1 = this.add.rectangle(x,y,w,h,color,0).setDepth(-6);
        g1.setRotation(angle);
        g1.setStrokeStyle(10, color, 0.12*glow);
        const g2 = this.add.rectangle(x,y,w,h,color,0).setDepth(-7);
        g2.setRotation(angle);
        g2.setStrokeStyle(20, color, 0.06*glow);
      }

      _staticWall(x,y,w,h,color=0x8efcff, angle=0){
        const body = this.matter.add.rectangle(x,y,w,h,{isStatic:true,restitution:1.12,friction:0.002,angle,label:'wall'});
        this._neonRect(x,y,w,h,color,0.02,2.4,angle);
        return body;
      }

      _bumper(x,y,r,color=0xffd84a){
        const body = this.matter.add.circle(x,y,r,{isStatic:true,restitution:1.35,friction:0.0008,label:'bumper'});
        const c = this.add.circle(x,y,r,color,0.08).setStrokeStyle(3,color,0.8).setDepth(-4);
        // glow
        const g = this.add.circle(x,y,r+10,color,0.03).setDepth(-6);
        // little kick (arcade feel)
        const sensor = this.matter.add.circle(x,y,r+14,{isStatic:true,isSensor:true,label:'bumperS'});
        this.matter.world.on('collisionstart', (evt)=>{
          for(const p of evt.pairs){
            const a=p.bodyA,b=p.bodyB;
            if ((a===sensor && b.label==='ball') || (b===sensor && a.label==='ball')){
              const ball = (b.label==='ball') ? b : a;
              const dx = ball.position.x - x, dy = ball.position.y - y;
              const d = Math.max(1, Math.hypot(dx,dy));
              const k = 0.0018;
              ball.force.x += (dx/d)*k*140;
              ball.force.y += (dy/d)*k*140;
            }
          }
        });
        return body;
      }

      _rotor(x,y,r,dir=1){
        // static center ring + tangential force sensor
        this.matter.add.circle(x,y,r,{isStatic:true,restitution:1.15,friction:0.001,label:'rotor'});
        const col = 0x7cfffb;
        this.add.circle(x,y,r,col,0.05).setStrokeStyle(3,col,0.7).setDepth(-4);
        this.add.circle(x,y,r+12,col,0.02).setDepth(-6);

        const sensor = this.matter.add.circle(x,y,r+28,{isStatic:true,isSensor:true,label:'rotorS'});
        this.matter.world.on('collisionstart',(evt)=>{
          for(const p of evt.pairs){
            const a=p.bodyA,b=p.bodyB;
            if ((a===sensor && b.label==='ball') || (b===sensor && a.label==='ball')){
              const ball = (b.label==='ball') ? b : a;
              const dx = ball.position.x - x, dy = ball.position.y - y;
              const d = Math.max(1, Math.hypot(dx,dy));
              const tx = -dy/d * dir;
              const ty =  dx/d * dir;
              const k = 0.0011;
              ball.force.x += tx*k*120;
              ball.force.y += ty*k*120;
            }
          }
        });
      }

      _blackHole(x,y,r){
        const col = 0xb38bff;
        const sensor = this.matter.add.circle(x,y,r,{isStatic:true,isSensor:true,label:'hole'});
        this.add.circle(x,y,r,0x000000,0.30).setStrokeStyle(3,col,0.55).setDepth(-4);
        this.add.circle(x,y,r+14,col,0.02).setDepth(-6);

        // pulling field (continuous)
        this.time.addEvent({
          delay:16, loop:true, callback:()=>{
            for(const s of this.balls){
              if(s._done) continue;
              const b=s.body;
              const dx=x-b.position.x, dy=y-b.position.y;
              const d=Math.hypot(dx,dy);
              if(d<r*2.2){
                const k=(1 - d/(r*2.2))*0.00055;
                b.force.x += (dx/d)*k*140;
                b.force.y += (dy/d)*k*140;
              }
            }
          }
        });

        // swallow -> re-inject (moderate shuffle, not "free win")
        this.time.addEvent({
          delay:90, loop:true, callback:()=>{
            for(const s of this.balls){
              if(s._done) continue;
              const b=s.body;
              const d=Math.hypot(x-b.position.x, y-b.position.y);
              if(d<r*0.42){
                const tx = WALL+70 + this.rng()*(W-2*WALL-140);
                const ty = Z3.y0+120 + this.rng()*(Z3.y1-Z3.y0-240);
                this.matter.body.setPosition(b,{x:tx,y:ty});
                this.matter.body.setVelocity(b,{x:(this.rng()-0.5)*4, y:(this.rng()-0.5)*2});
              }
            }
          }
        });
      }

      _announce(msg){
        const t = this.add.text(W/2, this.cameras.main.scrollY + 80, msg, {
          fontSize:'20px', fontStyle:'900', color:'#ffffff',
          stroke:'#000000', strokeThickness:6
        }).setOrigin(0.5).setAlpha(0).setDepth(50);
        this.tweens.add({targets:t, alpha:1, duration:180, yoyo:true, hold:1100, onComplete:()=>t.destroy()});
      }

      // ----- track / obstacles -----
      _buildTrack(){
        // side walls (neon)
        this._staticWall(WALL/2, WORLD_H/2, WALL, WORLD_H, 0x8efcff);
        this._staticWall(W - WALL/2, WORLD_H/2, WALL, WORLD_H, 0x8efcff);

        // Zone 1: bumper storm
        const chaos = this.cfg.chaos;
        const cols = 9;
        const rows = 14 + chaos*2;
        const xMin = WALL+60, xMax = W-WALL-60;
        const yMin = Z1.y0+120, yMax = Z1.y1-90;
        for(let r=0;r<rows;r++){
          const y = Phaser.Math.Linear(yMin,yMax, r/(rows-1));
          for(let c=0;c<cols;c++){
            const x = Phaser.Math.Linear(xMin,xMax, c/(cols-1)) + ((r%2)*18) + (this.rng()-0.5)*8;
            if (this.rng() < 0.80) this._bumper(x,y, 10+this.rng()*6);
          }
        }
        // angled deflectors (thicker neon)
        for(let i=0;i<10+chaos*2;i++){
          const x = xMin + this.rng()*(xMax-xMin);
          const y = yMin + this.rng()*(yMax-yMin);
          const w = 140 + this.rng()*90;
          const h = 18;
          const angle = (this.rng()<0.5 ? -1 : 1) * (0.25 + this.rng()*0.5);
          this.matter.add.rectangle(x,y,w,h,{isStatic:true,restitution:1.15,friction:0.001,angle,label:'def'});
          this._neonRect(x,y,w,h,0x7cfffb,0.02,2.2,angle);
        }

        // Zone 2: branching + moving gates
        const laneW = (W - 2*WALL - 40)/3;
        const y0 = Z2.y0+60, y1 = Z2.y1-60;
        for(let i=1;i<=2;i++){
          this._staticWall(WALL+20 + laneW*i, (y0+y1)/2, 12, (y1-y0), 0x6f7cff);
        }
        // gates
        for(let i=0;i<7+chaos;i++){
          const lane = Math.floor(this.rng()*3);
          const x = WALL+20 + laneW*lane + laneW/2;
          const y = y0 + this.rng()*(y1-y0);
          const w = laneW*0.68;
          const h = 18;
          const dx = 80 + this.rng()*70;
          const period = 900 + this.rng()*700;
          const body = this.matter.add.rectangle(x,y,w,h,{isStatic:true,restitution:1.10,friction:0.002,label:'gate'});
          this._neonRect(x,y,w,h,0xff6bd6,0.02,2.0,0);

          const t0p = performance.now();
          this.time.addEvent({
            delay:16, loop:true, callback:()=>{
              const t = (performance.now()-t0p)/period*Math.PI*2;
              const nx = x + Math.sin(t)*dx;
              this.matter.body.setPosition(body,{x:nx,y:y});
              // (ì‹œê°ì€ ê³ ì • ë„¤ì˜¨ì´ë¼, ìœ„ì¹˜ê°ì€ ì¶©ë¶„íˆ ë‚¨. í•„ìš”í•˜ë©´ rectë„ ì›€ì§ì´ê²Œ ë°”ê¿€ ìˆ˜ ìˆìŒ)
            }
          });
        }
        for(let i=0;i<24+chaos*5;i++){
          const x = WALL+60 + this.rng()*(W-2*WALL-120);
          const y = y0 + this.rng()*(y1-y0);
          this._bumper(x,y, 10+this.rng()*6, 0xffd84a);
        }

        // Zone 3: rotors
        const yMid = (Z3.y0+Z3.y1)/2;
        this._rotor(W/2, yMid, 62, (this.rng()<0.5?1:-1));
        this._rotor(W*0.28, yMid-260, 48, 1);
        this._rotor(W*0.72, yMid+250, 48, -1);
        for(let i=0;i<70+chaos*10;i++){
          const x = WALL+60 + this.rng()*(W-2*WALL-120);
          const y = Z3.y0+120 + this.rng()*(Z3.y1-Z3.y0-240);
          this._bumper(x,y, 9+this.rng()*5, 0x2cff9a);
        }

        // Zone 4: black holes
        const holes = 2 + (chaos>=4 ? 1 : 0);
        for(let i=0;i<holes;i++){
          const x = WALL+140 + this.rng()*(W-2*WALL-280);
          const y = Z4.y0+120 + this.rng()*(Z4.y1-Z4.y0-240);
          this._blackHole(x,y, 52 + this.rng()*14);
        }

        // Final corridor + bumpers
        const fy0 = ZF.y0+40, fy1 = ZF.y1-160;
        this._staticWall(WALL+92, (fy0+fy1)/2, 14, (fy1-fy0), 0x2cff9a);
        this._staticWall(W-(WALL+92), (fy0+fy1)/2, 14, (fy1-fy0), 0x2cff9a);
        for(let i=0;i<18+chaos*3;i++){
          const x = WALL+120 + this.rng()*(W-2*WALL-240);
          const y = fy0 + this.rng()*(fy1-fy0);
          this._bumper(x,y, 10+this.rng()*6, 0x7cfffb);
        }
      }

      // ----- spawning -----
      _pickBallCount(maxBalls){
        if (!this.cfg.rndBalls) return maxBalls;
        const r=this.rng();
        if(maxBalls<=1) return 1;
        if(maxBalls===2) return (r<0.55)?1:2;
        if(r<0.45) return 1;
        if(r<0.80) return 2;
        return 3;
      }
      _pickBallType(){
        if(!this.cfg.rndSize) return {radius:14,density:0.0022,restitution:1.22};
        const c=this.cfg.chaos;
        const r=this.rng();
        const giant = 0.02 + c*0.01;
        const large = 0.20 + c*0.03;
        const small = 0.25 + c*0.02;
        if(r<giant) return {radius:23,density:0.0038,restitution:1.06};
        if(r<giant+large) return {radius:18,density:0.0031,restitution:1.10};
        if(r<giant+large+small) return {radius:12,density:0.0018,restitution:1.30};
        return {radius:14,density:0.0022,restitution:1.22};
      }

      _spawn(){
        const namesRaw = this.cfg.names;
        const maxPlayers = clamp(this.cfg.maxPlayers,2,20);
        let pool = namesRaw.length ? namesRaw : Array.from({length:maxPlayers},(_,i)=>`P${i+1}`);

        // choose players
        let chosen = pool.slice(0, maxPlayers);
        if (this.cfg.rndPlayers && pool.length>2){
          // pick random subset size 2..maxPlayers
          const size = 2 + Math.floor(this.rng()*(maxPlayers-1));
          // shuffle pool
          for(let i=pool.length-1;i>0;i--){
            const j=Math.floor(this.rng()*(i+1));
            [pool[i],pool[j]]=[pool[j],pool[i]];
          }
          chosen = pool.slice(0,size);
        }

        const maxBalls = clamp(this.cfg.maxBalls,1,3);

        // nice palette
        const colors = [
          0x7cfffb,0xff6bd6,0xffd84a,0x2cff9a,0xb38bff,0xff8a4a,0x6f7cff,
          0xff4d6d,0x4dff88,0x4d7dff,0xfff04d,0x8a4dff,0x4dfff0,0xff4df0,
          0xaaff4d,0x4dffaa,0xffaa4d,0xaa4dff,0x4daaff,0xffffff
        ];

        const startY = 72;
        const span = W - 2*WALL - 160;

        for(let i=0;i<chosen.length;i++){
          const count = this._pickBallCount(maxBalls);
          for(let k=0;k<count;k++){
            const t = this._pickBallType();
            const x = WALL+80 + (i/Math.max(1,chosen.length-1))*span + (this.rng()-0.5)*22 + (k-0.5)*10;
            const y = startY - k*22;
            const col = colors[i % colors.length];

            const ball = this.add.circle(x,y,t.radius,col,0.22).setStrokeStyle(3,col,0.85);
            this.matter.add.gameObject(ball,{
              shape:{type:'circle',radius:t.radius},
              label:'ball',
              friction:0.002,
              frictionAir:0.003,
              restitution:t.restitution,
              density:t.density
            });

            ball.setVelocity((this.rng()-0.5)*2.2, 0.5+this.rng()*0.7);
            ball._done=false;
            ball._name=chosen[i];
            ball._i=i; ball._k=k;

            // label with outline (VERY readable)
            let txt=null;
            if(this.cfg.showNames){
              txt = this.add.text(x,y, chosen[i], {
                fontSize:'16px',
                fontStyle:'900',
                color:'#ffffff',
                stroke:'#000000',
                strokeThickness:6
              }).setOrigin(0.5,1).setDepth(30);
            }
            this.balls.push(ball);
            this.labels.push(txt);
          }
        }
        this.total = this.balls.length;
      }

      _finalEvent(){
        this.finalEventFired = true;
        const roll=this.rng();
        let msg='FINAL: (ì•„ë¬´ ì¼ ì—†ìŒ)';
        if(roll<0.40){
          // none
        } else if(roll<0.65){
          msg='FINAL: ì „ì› ê°€ì†';
          this.matter.world.setGravity(0, 1.28);
          this.time.delayedCall(2200, ()=>this.matter.world.setGravity(0,1.12));
        } else if(roll<0.80){
          msg='FINAL: ì¶©ê²©íŒŒ';
          const cx=W/2, cy=ZF.y0+220;
          for(const s of this.balls){
            if(s._done) continue;
            if(s.y<ZF.y0-220 || s.y>ZF.y1) continue;
            const b=s.body;
            const dx=b.position.x-cx, dy=b.position.y-cy;
            const d=Math.max(1, Math.hypot(dx,dy));
            const k=(1 - Math.min(1, d/280))*0.0020;
            b.force.x += (dx/d)*k*320;
            b.force.y += (dy/d)*k*260;
          }
        } else if(roll<0.90){
          msg='FINAL: ìœ„ì¹˜ êµì²´(2ê°œ)';
          const cand=this.balls.filter(s=>!s._done && s.y>ZF.y0-140 && s.y<ZF.y1-60);
          if(cand.length>=2){
            const a=cand[Math.floor(this.rng()*cand.length)];
            let b=cand[Math.floor(this.rng()*cand.length)];
            if(a===b) b=cand[(cand.indexOf(a)+1)%cand.length];
            const pa={x:a.body.position.x,y:a.body.position.y};
            const pb={x:b.body.position.x,y:b.body.position.y};
            this.matter.body.setPosition(a.body,pb);
            this.matter.body.setPosition(b.body,pa);
          } else {
            msg='FINAL: (êµì²´ ì‹¤íŒ¨â†’ì—†ìŒ)';
          }
        } else {
          msg='FINAL: ëˆì ì¡´(ì ê¹)';
          for(const s of this.balls){
            if(!s._done && s.y>ZF.y0-240 && s.y<ZF.y1) s.setFrictionAir(0.020);
          }
          this.time.delayedCall(2000, ()=>{
            for(const s of this.balls){ if(!s._done) s.setFrictionAir(0.003); }
          });
        }
        this._announce(msg);
      }

      _updateHUD(){
        const t=(performance.now()-this.startAt)/1000;
        const alive=this.total-this.finished;
        const hud=document.getElementById('hud');
        const mini=document.getElementById('miniHud');

        // show top 8 by progress
        const ongoing=this.balls.filter(s=>!s._done).sort((a,b)=>b.y-a.y);
        const top=ongoing.slice(0,8).map(s=>s._name).join(', ');

        const text =
          `ì§„í–‰: <b>${this.finished}</b> / ${this.total} (ë‚¨ìŒ ${alive})<br>`+
          `ê²½ê³¼: ${t.toFixed(1)}s<br>`+
          `ì„ ë‘ê¶Œ: ${top || 'â€”'}<br>`+
          `FINAL: ${this.finalEventFired ? 'ë°œë™ë¨' : 'ëŒ€ê¸°ì¤‘'}`;

        hud.innerHTML=text;
        mini.textContent = `ì§„í–‰ ${this.finished}/${this.total} Â· ${t.toFixed(1)}s`;
      }
    }

    let game=null;

    function getCfg(){
      const names = parseNames(document.getElementById('names').value);
      return {
        names,
        maxPlayers: parseInt(document.getElementById('maxPlayers').value,10)||20,
        maxBalls: parseInt(document.getElementById('maxBalls').value,10)||2,
        chaos: clamp(parseInt(document.getElementById('chaos').value,10)||3,0,5),
        seed: parseInt(document.getElementById('seed').value,10)||12345,
        rndPlayers: document.getElementById('rndPlayers').checked,
        rndBalls: document.getElementById('rndBalls').checked,
        rndSize: document.getElementById('rndSize').checked,
        showNames: document.getElementById('showNames').checked
      };
    }

    function start(){
      const cfg=getCfg();
      if(game){ game.destroy(true); game=null; }
      game = new Phaser.Game({
        type: Phaser.AUTO,
        backgroundColor:'#05060b',
        width: window.innerWidth,
        height: window.innerHeight,
        physics:{
          default:'matter',
          matter:{ gravity:{y:1.12}, enableSleep:true, debug:false }
        },
        scene:[ new Main() ]
      });
      game.scene.start('main', {cfg});
    }

    function newSeed(){
      document.getElementById('seed').value = 1 + Math.floor(Math.random()*999999);
    }

    // fold/unfold
    const panel=document.getElementById('panel');
    const mini=document.getElementById('mini');
    document.getElementById('toggleBtn').onclick=()=>{
      panel.style.display='none';
      mini.style.display='block';
    };
    document.getElementById('openBtn').onclick=()=>{
      panel.style.display='block';
      mini.style.display='none';
    };

    document.getElementById('startBtn').onclick=start;
    document.getElementById('startBtn2').onclick=start;
    document.getElementById('seedBtn').onclick=newSeed;

    start();
  </script>
</body>
</html>
