<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no"/>
  <title>Marble Roulette Mobile Y-Final v4</title>
  <style>
    html,body{
      margin:0;height:100%;
      background:#05060b;color:#fff;
      font-family:system-ui,-apple-system,Segoe UI,Roboto;
      overflow:hidden;
      touch-action:none;          /* ëª¨ë°”ì¼ ì œìŠ¤ì²˜ë¡œ ì´ë²¤íŠ¸ ì”¹í˜ ë°©ì§€ */
      -webkit-user-select:none;
      user-select:none;
    }
    canvas{display:block;touch-action:none}

    /* ëª¨ë°”ì¼ìš© í° UI */
    #panel{
      position:fixed;left:10px;top:10px;right:10px;z-index:20;
      background:rgba(10,12,20,.88);
      border:1px solid rgba(255,255,255,.14);
      border-radius:16px;
      box-shadow:0 10px 40px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
      overflow:hidden;
      max-width:560px;
      margin:0 auto;
    }
    header{
      display:flex;align-items:center;justify-content:space-between;
      padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.10);
      gap:10px;
    }
    .title{font-weight:900;font-size:13px;letter-spacing:.2px}
    .sub{font-size:11px;opacity:.75}
    .right{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end}
    button{
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(20,26,44,.95);
      color:#fff;cursor:pointer;font-weight:900;
      touch-action:manipulation;  /* ëª¨ë°”ì¼ íƒ­ ì•ˆì • */
    }
    button:active{transform:scale(0.98)}
    #body{padding:10px 12px}
    textarea{
      width:100%;min-height:74px;resize:vertical;
      padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,.14);
      background:#0b0f1f;color:#fff;font-size:12px;line-height:1.4;
      touch-action:auto;
    }
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:10px}
    label{display:flex;gap:8px;align-items:center;font-size:12px;opacity:.92}
    input[type="number"]{
      width:88px;padding:8px 10px;border-radius:12px;border:1px solid rgba(255,255,255,.14);
      background:#0b0f1f;color:#fff
    }
    input[type="checkbox"]{transform:scale(1.15)}
    #hud{
      margin-top:10px;
      padding:10px;border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.25);
      font-size:12px;line-height:1.55;opacity:.95
    }

    /* ì ‘íŒ ë¯¸ë‹ˆ HUD */
    #mini{
      position:fixed;left:10px;top:10px;z-index:21;display:none;
      right:10px;max-width:560px;margin:0 auto;
      padding:10px 12px;border-radius:16px;border:1px solid rgba(255,255,255,.14);
      background:rgba(10,12,20,.88);backdrop-filter: blur(10px);
      box-shadow:0 10px 40px rgba(0,0,0,.45);
    }
    #mini .row2{display:flex;justify-content:space-between;gap:10px;align-items:center;flex-wrap:wrap}
    #miniHud{font-size:11px;opacity:.8}

    #err{
      position:fixed;left:10px;right:10px;bottom:10px;z-index:50;
      background:rgba(255,80,80,.12);
      border:1px solid rgba(255,80,80,.45);
      border-radius:14px;
      padding:10px 12px;
      font-size:12px;line-height:1.45;
      display:none;
      max-width:560px;margin:0 auto;
    }
    kbd{
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas;
      font-size:11px;
      padding:2px 6px;border-radius:8px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.06)
    }
  </style>
</head>
<body>
  <div id="mini">
    <div class="row2">
      <div>
        <div style="font-weight:900;font-size:12px;">ğŸ° Marble Drop v4 (Mobile)</div>
        <div id="miniHud">ëŒ€ê¸°ì¤‘â€¦</div>
      </div>
      <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end">
        <button id="openBtn">ì„¤ì •</button>
        <button id="startBtn2">ì‹œì‘</button>
      </div>
    </div>
  </div>

  <div id="panel">
    <header>
      <div>
        <div class="title">ğŸ° Marble Drop v4 â€” ë§ˆì§€ë§‰ Y ë¶„ê¸° ë£°ë ›</div>
        <div class="sub">ëª¨ë°”ì¼ ìµœì í™” Â· <kbd>C</kbd> ì¹´ë©”ë¼ëª¨ë“œ Â· <kbd>Z</kbd> ì¤Œí† ê¸€</div>
      </div>
      <div class="right">
        <button id="toggleBtn">ì ‘ê¸°</button>
        <button id="startBtn">START</button>
        <button id="seedBtn">SEED</button>
      </div>
    </header>

    <div id="body">
      <div style="font-size:12px;opacity:.9;margin-bottom:8px">ì´ë¦„ (ì½¤ë§ˆ/ì¤„ë°”ê¿ˆ OK, ê°€ì¤‘ì¹˜ *N)</div>
      <textarea id="names">ì§±êµ¬*5, ì§±ì•„*10, ë´‰ë¯¸ì„ *3</textarea>

      <div class="row">
        <label>ìµœëŒ€ ì¸ì›(2~20) <input id="maxPlayers" type="number" min="2" max="20" value="20"></label>
        <label>ìµœëŒ€ ê³µ/ì¸(1~3) <input id="maxBalls" type="number" min="1" max="3" value="2"></label>
        <label>í˜¼ëˆ(0~5) <input id="chaos" type="number" min="0" max="5" value="3"></label>
        <label>ì‹œë“œ <input id="seed" type="number" min="1" max="999999" value="12345"></label>
      </div>

      <div class="row">
        <label><input id="rndPlayers" type="checkbox" checked> ì¸ì› ëœë¤</label>
        <label><input id="rndBalls" type="checkbox" checked> ê³µ ìˆ˜ ëœë¤</label>
        <label><input id="rndSize" type="checkbox" checked> í¬ê¸°/ë¬´ê²Œ ëœë¤</label>
        <label><input id="showNames" type="checkbox" checked> ì´ë¦„ í‘œì‹œ</label>
        <label><input id="autoZoom" type="checkbox" checked> ìë™ ì¤Œ</label>
      </div>

      <div id="hud">ëŒ€ê¸°ì¤‘â€¦</div>
    </div>
  </div>

  <div id="err"></div>

  <!-- NOTE: CDNì´ ë§‰íˆë©´ ì‹¤í–‰ ë¶ˆê°€. ê·¸ ê²½ìš° phaser.min.jsë¥¼ ë¡œì»¬ë¡œ ë„£ì–´ì•¼ í•¨ -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
  <script>
    // ---- show error helper ----
    function showErr(msg){
      const el=document.getElementById('err');
      el.style.display='block';
      el.innerHTML = msg;
    }

    // Phaser ë¡œë”© ì‹¤íŒ¨ ì²´í¬
    if (typeof Phaser === 'undefined'){
      showErr(
        'âš ï¸ Phaser ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ëª» ë¶ˆëŸ¬ì™”ì–´.<br>' +
        'ì‚¬ë‚´ë§/ëª¨ë°”ì¼ì—ì„œ CDNì´ ë§‰íˆë©´ ì‹œì‘ì´ ì•ˆ ë¼.<br>' +
        'í•´ê²°: phaser.min.jsë¥¼ íŒŒì¼ë¡œ ë‚´ë ¤ë°›ì•„ ê°™ì€ í´ë”ì— ë‘ê³ , ' +
        'script srcë¥¼ ë¡œì»¬ë¡œ ë°”ê¿”ì•¼ í•´.'
      );
    }

    // ---------- deterministic RNG ----------
    function mulberry32(a){
      return function(){
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      }
    }
    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));

    // ---------- parse names ----------
    function parseNames(raw){
      const parts = raw.replace(/\r/g,'').split(/[\n,]+/).map(s=>s.trim()).filter(Boolean);
      const out=[];
      for(const p of parts){
        const m=p.match(/^(.+?)\s*\*\s*(\d+)$/);
        if(m){
          const name=m[1].trim();
          const n=clamp(parseInt(m[2],10)||1,1,999);
          for(let i=0;i<n;i++) out.push(name);
        }else out.push(p);
      }
      return out.slice(0,200);
    }

    // ---------- world dims ----------
    const W=780;
    const VIEW_H=940;
    const WORLD_H=6000;
    const WALL=26;

    const Z1={y0:140,  y1:1800};
    const Z2={y0:1800, y1:3500};
    const Z3={y0:3500, y1:4650};
    const Z4={y0:4650, y1:5400};
    const ZF={y0:5400, y1:5920}; // final with Y

    class Main extends Phaser.Scene {
      constructor(){ super('main'); }

      init(data){
        this.cfg=data.cfg;
        this.rng=mulberry32(this.cfg.seed|0);
        this.balls=[]; this.labels=[];
        this.total=0; this.finished=0;
        this.startAt=0;
        this.finalEventFired=false;
        this.camMode=0; // 0 AVG,1 LEAD,2 LAST,3 CHAOS
        this.autoZoom=!!this.cfg.autoZoom;
      }

      create(){
        // physics
        this.matter.world.setBounds(0,0,W,WORLD_H,64,true,true,false,true);
        this.matter.world.engine.positionIterations=10;
        this.matter.world.engine.velocityIterations=8;
        this.matter.world.setGravity(0,1.12);

        // camera
        this.cameras.main.setBounds(0,0,W,WORLD_H);
        this.cameras.main.setViewport(0,0,window.innerWidth,window.innerHeight);
        this.cameras.main.setZoom(1.12);

        this.scale.on('resize', (gs)=>{
          this.cameras.main.setViewport(0,0,gs.width,gs.height);
          if (this.minimap) this.minimap.setPosition(gs.width - 220, 14);
        });

        // keys
        this.input.keyboard.on('keydown-C', ()=>{
          this.camMode=(this.camMode+1)%4;
          this._announce('CAM: ' + ['AVG','LEAD','LAST','CHAOS'][this.camMode]);
        });
        this.input.keyboard.on('keydown-Z', ()=>{
          this.autoZoom=!this.autoZoom;
          this._announce('ZOOM: ' + (this.autoZoom?'AUTO':'LOCK'));
        });

        // background + track
        this._drawNeonBG();
        this._buildTrack();

        // spawn
        this._spawnPlayers();

        // finish sensors (ì¢Œ/ìš° ê³¨ì¸)
        this.finishL = this.matter.add.rectangle(W*0.28, WORLD_H-90, 210, 18, {isStatic:true,isSensor:true,label:'finishL'});
        this.finishR = this.matter.add.rectangle(W*0.72, WORLD_H-90, 210, 18, {isStatic:true,isSensor:true,label:'finishR'});
        this._neonRect(W*0.28, WORLD_H-90, 210, 18, 0x2cff9a, 0.18, 2.2);
        this._neonRect(W*0.72, WORLD_H-90, 210, 18, 0x2cff9a, 0.18, 2.2);

        // collision: finish
        this.matter.world.on('collisionstart', (evt)=>{
          for(const pair of evt.pairs){
            const a=pair.bodyA, b=pair.bodyB;
            const isBallA=a.label==='ball', isBallB=b.label==='ball';
            const isFLA=a.label==='finishL'||a.label==='finishR';
            const isFLB=b.label==='finishL'||b.label==='finishR';
            if ((isBallA && isFLB) || (isBallB && isFLA)){
              const ballBody = isBallA ? a : b;
              const s = ballBody.gameObject;
              if(s && !s._done){
                s._done=true;
                this.finished++;
                s.setStatic(true);
                this.tweens.add({targets:s, alpha:0.35, duration:240});
              }
            }
          }
        });

        // minimap
        this.minimap = this.cameras.add(window.innerWidth - 220, 14, 200, 280)
          .setZoom(0.08)
          .setBounds(0,0,W,WORLD_H)
          .setBackgroundColor(0x000000)
          .setAlpha(0.78);

        // trails
        this.trailG = this.add.graphics().setDepth(-2);

        this.startAt=performance.now();

        // HUD
        this.time.addEvent({delay:120, loop:true, callback:()=>this._updateHUD()});

        // bombs visible (2s)
        this.time.addEvent({
          delay:2000, loop:true, callback:()=>{
            const y = this.cameras.main.scrollY + 520 + this.rng()*260;
            const x = WALL+120 + this.rng()*(W-2*WALL-240);
            this._bombShockwave(x,y);
          }
        });

        // final moderate event after ~55s near final
        this.time.addEvent({
          delay:250, loop:true, callback:()=>{
            const t=(performance.now()-this.startAt)/1000;
            if(!this.finalEventFired && t>55){
              const near=this.balls.some(s=>!s._done && s.y>ZF.y0-260);
              if(near) this._finalEvent();
            }
          }
        });
      }

      update(){
        // safety respawn if ejected
        for(const s of this.balls){
          if(s._done) continue;
          if(s.y>WORLD_H+260 || s.x<-260 || s.x>W+260){
            const b=s.body;
            const tx=WALL+90 + this.rng()*(W-2*WALL-180);
            const ty=Z4.y0+220 + this.rng()*240;
            this.matter.body.setPosition(b,{x:tx,y:ty});
            this.matter.body.setVelocity(b,{x:(this.rng()-0.5)*2, y:1});
          }
        }

        // camera follow
        const alive=this.balls.filter(s=>!s._done);
        if(alive.length){
          let targetY;
          if(this.camMode===1){ // LEAD
            alive.sort((a,b)=>b.y-a.y);
            targetY=alive[0].y - VIEW_H*0.35;
          } else if(this.camMode===2){ // LAST
            alive.sort((a,b)=>a.y-b.y);
            targetY=alive[0].y - VIEW_H*0.35;
          } else if(this.camMode===3){ // CHAOS densest
            const buckets=new Map();
            for(const s of alive){
              const key=Math.floor(s.y/260);
              buckets.set(key,(buckets.get(key)||0)+1);
            }
            let bestK=0,bestC=-1;
            for(const [k,c] of buckets.entries()){ if(c>bestC){bestC=c;bestK=k;} }
            targetY=bestK*260 - VIEW_H*0.25;
          } else { // AVG
            const avg=alive.reduce((sum,s)=>sum+s.y,0)/alive.length;
            targetY=avg - VIEW_H*0.38;
          }
          targetY=clamp(targetY,0,WORLD_H-VIEW_H);
          this.cameras.main.scrollY = Phaser.Math.Linear(this.cameras.main.scrollY, targetY, 0.10);

          if(this.autoZoom){
            const ys=alive.map(s=>s.y);
            const spread=Math.max(...ys)-Math.min(...ys);
            const zoom=clamp(1.25 - (spread/1800), 0.85, 1.25);
            this.cameras.main.setZoom(Phaser.Math.Linear(this.cameras.main.zoom, zoom, 0.06));
          }
        }

        // trails
        this.trailG.clear();
        for(const s of this.balls){
          if(s._done) continue;
          if(!s._trail) s._trail=[];
          s._trail.push({x:s.x,y:s.y});
          if(s._trail.length>14) s._trail.shift();

          const col=s.fillColor ?? 0xffffff;
          for(let i=1;i<s._trail.length;i++){
            const a=s._trail[i-1], b=s._trail[i];
            const alpha=(i/s._trail.length)*0.32;
            this.trailG.lineStyle(5,col,alpha);
            this.trailG.beginPath();
            this.trailG.moveTo(a.x,a.y);
            this.trailG.lineTo(b.x,b.y);
            this.trailG.strokePath();
          }
        }

        // labels follow
        if(this.cfg.showNames){
          for(let i=0;i<this.balls.length;i++){
            const s=this.balls[i], t=this.labels[i];
            if(!t) continue;
            t.setPosition(s.x, s.y - s.displayHeight*0.85);
            t.setVisible(!s._done);
          }
        }
      }

      // ---------- visuals ----------
      _drawNeonBG(){
        const g=this.add.graphics().setDepth(-30);
        g.lineStyle(1, 0x1f284a, 0.30);
        for(let y=0;y<=WORLD_H;y+=92){ g.beginPath(); g.moveTo(0,y); g.lineTo(W,y); g.strokePath(); }
        for(let x=0;x<=W;x+=92){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,WORLD_H); g.strokePath(); }
      }
      _neonRect(x,y,w,h,color,fillAlpha=0.06, glow=2.0, angle=0){
        const r=this.add.rectangle(x,y,w,h,color,fillAlpha).setDepth(-10);
        r.setRotation(angle);
        r.setStrokeStyle(3,color,0.88);
        const g1=this.add.rectangle(x,y,w,h,color,0).setDepth(-11);
        g1.setRotation(angle); g1.setStrokeStyle(10,color,0.12*glow);
        const g2=this.add.rectangle(x,y,w,h,color,0).setDepth(-12);
        g2.setRotation(angle); g2.setStrokeStyle(20,color,0.06*glow);
      }
      _staticWall(x,y,w,h,color=0x8efcff, angle=0){
        const body=this.matter.add.rectangle(x,y,w,h,{isStatic:true,restitution:1.14,friction:0.001,angle,label:'wall'});
        this._neonRect(x,y,w,h,color,0.02,2.5,angle);
        return body;
      }
      _bumper(x,y,r,color=0xffd84a){
        this.matter.add.circle(x,y,r,{isStatic:true,restitution:1.38,friction:0.0008,label:'bumper'});
        this.add.circle(x,y,r,color,0.08).setStrokeStyle(3,color,0.85).setDepth(-9);
        this.add.circle(x,y,r+12,color,0.02).setDepth(-12);
      }
      _addSpinnerBar(x,y,len=260,th=18, speed=0.012){
        const bar=this.matter.add.rectangle(x,y,len,th,{isStatic:true,restitution:1.25,friction:0.001,label:'spinner'});
        this._neonRect(x,y,len,th,0x00ffff,0.02,2.9,0);
        this.time.addEvent({delay:16, loop:true, callback:()=>this.matter.body.rotate(bar, speed)});
      }
      _rotorRoulette(x,y,r, speed=0.015){
        // ì¤‘ì•™ ë£°ë › í”Œë¦¬í¼(ì› + íšŒì „ë§‰ëŒ€) : Y ë¶„ê¸° ì•ì—ì„œ â€œëˆ„ê°€ ë¹ ì ¸ë‚˜ê°ˆì§€â€ ê²°ì •
        this.matter.add.circle(x,y,r,{isStatic:true,restitution:1.10,friction:0.001,label:'rouletteHub'});
        this.add.circle(x,y,r,0x7cfffb,0.05).setStrokeStyle(3,0x7cfffb,0.8).setDepth(-9);
        this.add.circle(x,y,r+14,0x7cfffb,0.02).setDepth(-12);

        const bar=this.matter.add.rectangle(x,y,r*2.4,18,{isStatic:true,restitution:1.30,friction:0.001,label:'rouletteBar'});
        this._neonRect(x,y,r*2.4,18,0xff6bd6,0.02,2.6,0);

        this.time.addEvent({delay:16, loop:true, callback:()=>this.matter.body.rotate(bar, speed)});
      }
      _movingGate(x,y,w,h, dx, periodMs){
        const body=this.matter.add.rectangle(x,y,w,h,{isStatic:true,restitution:1.12,friction:0.001,label:'gate'});
        const rect=this.add.rectangle(x,y,w,h,0xff6bd6,0.05).setStrokeStyle(3,0xff6bd6,0.85).setDepth(-9);
        const glow1=this.add.rectangle(x,y,w,h,0xff6bd6,0).setStrokeStyle(12,0xff6bd6,0.12).setDepth(-11);
        const glow2=this.add.rectangle(x,y,w,h,0xff6bd6,0).setStrokeStyle(24,0xff6bd6,0.06).setDepth(-12);

        const t0=performance.now();
        this.time.addEvent({
          delay:16, loop:true, callback:()=>{
            const t=(performance.now()-t0)/periodMs*Math.PI*2;
            const nx=x + Math.sin(t)*dx;
            this.matter.body.setPosition(body,{x:nx,y:y});
            rect.setPosition(nx,y); glow1.setPosition(nx,y); glow2.setPosition(nx,y);
          }
        });
      }
      _blackHole(x,y,r){
        const col=0xb38bff;
        this.matter.add.circle(x,y,r,{isStatic:true,isSensor:true,label:'hole'});
        this.add.circle(x,y,r,0x000000,0.32).setStrokeStyle(3,col,0.55).setDepth(-9);
        this.add.circle(x,y,r+14,col,0.02).setDepth(-12);

        // pull
        this.time.addEvent({
          delay:16, loop:true, callback:()=>{
            for(const s of this.balls){
              if(s._done) continue;
              const b=s.body;
              const dx=x-b.position.x, dy=y-b.position.y;
              const d=Math.hypot(dx,dy);
              if(d<r*2.2){
                const k=(1-d/(r*2.2))*0.00060;
                b.force.x += (dx/d)*k*150;
                b.force.y += (dy/d)*k*150;
              }
            }
          }
        });

        // swallow -> warp (delete ê¸ˆì§€)
        this.time.addEvent({
          delay:90, loop:true, callback:()=>{
            for(const s of this.balls){
              if(s._done) continue;
              const b=s.body;
              const d=Math.hypot(x-b.position.x, y-b.position.y);
              if(d<r*0.42){
                this._warpEffect(b.position.x, b.position.y);
                const tx=WALL+100 + this.rng()*(W-2*WALL-200);
                const ty=Z3.y0+180 + this.rng()*(Z3.y1-Z3.y0-360);
                this.matter.body.setPosition(b,{x:tx,y:ty});
                this.matter.body.setVelocity(b,{x:(this.rng()-0.5)*4, y:(this.rng()-0.5)*2});
                this._warpEffect(tx,ty);
              }
            }
          }
        });
      }
      _warpEffect(x,y){
        const g=this.add.graphics().setDepth(60);
        const col=0xb38bff;
        let r=10, a=0.7;
        this.time.addEvent({
          delay:16, repeat:18, callback:()=>{
            g.clear();
            g.lineStyle(6,col,a);
            g.strokeCircle(x,y,r);
            r+=10; a*=0.90;
          },
          onComplete:()=>g.destroy()
        });
      }
      _announce(msg){
        const t=this.add.text(W/2, this.cameras.main.scrollY + 90, msg, {
          fontSize:'20px', fontStyle:'900', color:'#ffffff',
          stroke:'#000000', strokeThickness:6
        }).setOrigin(0.5).setAlpha(0).setDepth(80);
        this.tweens.add({targets:t, alpha:1, duration:170, yoyo:true, hold:900, onComplete:()=>t.destroy()});
      }

      // ---------- map ----------
      _buildTrack(){
        // outer walls
        this._staticWall(WALL/2, WORLD_H/2, WALL, WORLD_H, 0x8efcff);
        this._staticWall(W - WALL/2, WORLD_H/2, WALL, WORLD_H, 0x8efcff);

        const chaos=this.cfg.chaos;

        // Zone1 bumpers
        const cols=9, rows=15+chaos*2;
        const xMin=WALL+70, xMax=W-WALL-70;
        const yMin=Z1.y0+140, yMax=Z1.y1-110;
        for(let r=0;r<rows;r++){
          const y=Phaser.Math.Linear(yMin,yMax,r/(rows-1));
          for(let c=0;c<cols;c++){
            const x=Phaser.Math.Linear(xMin,xMax,c/(cols-1)) + ((r%2)*18) + (this.rng()-0.5)*10;
            if(this.rng()<0.82) this._bumper(x,y,10+this.rng()*6,0xffd84a);
          }
        }

        // Zone2: gates + spinners
        const laneW=(W-2*WALL-40)/3;
        const y0=Z2.y0+70, y1=Z2.y1-70;
        for(let i=1;i<=2;i++){
          this._staticWall(WALL+20 + laneW*i, (y0+y1)/2, 12, (y1-y0), 0x6f7cff);
        }
        for(let i=0;i<7+chaos;i++){
          const lane=Math.floor(this.rng()*3);
          const x=WALL+20 + laneW*lane + laneW/2;
          const y=y0 + this.rng()*(y1-y0);
          this._movingGate(x,y,laneW*0.70,18, 90+this.rng()*70, 850+this.rng()*650);
        }
        this._addSpinnerBar(W*0.30, Z2.y0+620, 280, 18, 0.015);
        this._addSpinnerBar(W*0.70, Z2.y0+980, 260, 18, -0.014);
        this._addSpinnerBar(W*0.50, Z2.y0+1380, 300, 18, 0.016);

        // Zone3: bumper forest
        for(let i=0;i<75+chaos*12;i++){
          const x=WALL+70+this.rng()*(W-2*WALL-140);
          const y=Z3.y0+140+this.rng()*(Z3.y1-Z3.y0-280);
          this._bumper(x,y, 9+this.rng()*5, 0x2cff9a);
        }

        // Zone4: blackholes
        const holes=(chaos>=3)?3:2;
        for(let i=0;i<holes;i++){
          const x=WALL+160+this.rng()*(W-2*WALL-320);
          const y=Z4.y0+160+this.rng()*(Z4.y1-Z4.y0-320);
          this._blackHole(x,y,56+this.rng()*14);
        }

        // ---------- FINAL: Y junction ----------
        // ì¤‘ì•™ í†µë¡œ -> Yë¡œ ê°ˆë¼ì§ + ë£°ë › ë°” + ì¢Œìš° ê²Œì´íŠ¸ë¡œ ì˜ˆì¸¡ë¶ˆê°€
        const fyTop = ZF.y0 + 80;
        const yJunc = ZF.y0 + 260;
        const yEnd  = WORLD_H - 140;

        // ì¤‘ì•™ ì„¸ë¡œ í†µë¡œ ë²½
        this._staticWall(W*0.5 - 120, (fyTop+yJunc)/2, 14, (yJunc-fyTop), 0x2cff9a);
        this._staticWall(W*0.5 + 120, (fyTop+yJunc)/2, 14, (yJunc-fyTop), 0x2cff9a);

        // Y ì¢Œ/ìš° ë²½(ëŒ€ê°)
        // ì™¼ìª½ ê°€ì§€
        this._staticWall(W*0.38, (yJunc+yEnd)/2, 14, (yEnd-yJunc), 0x8efcff, -0.40);
        this._staticWall(W*0.18, (yJunc+yEnd)/2, 14, (yEnd-yJunc), 0x8efcff, -0.40);
        // ì˜¤ë¥¸ìª½ ê°€ì§€
        this._staticWall(W*0.62, (yJunc+yEnd)/2, 14, (yEnd-yJunc), 0x8efcff, 0.40);
        this._staticWall(W*0.82, (yJunc+yEnd)/2, 14, (yEnd-yJunc), 0x8efcff, 0.40);

        // Y ë¶„ê¸° ë°”ë¡œ ì• ë£°ë ›(íšŒì „ ë§‰ëŒ€)
        this._rotorRoulette(W/2, yJunc-30, 58, 0.018 + chaos*0.002);

        // ì¢Œìš° ì¶œêµ¬ì— ì›€ì§ì´ëŠ” ê²Œì´íŠ¸(ëê¹Œì§€ ëª¨ë¥´ê²Œ)
        this._movingGate(W*0.28, yJunc+180, 220, 18, 70, 900);
        this._movingGate(W*0.72, yJunc+180, 220, 18, 70, 900);

        // ë§ˆì§€ë§‰ ë²”í¼ ëª‡ ê°œ
        for(let i=0;i<18+chaos*3;i++){
          const x=WALL+110+this.rng()*(W-2*WALL-220);
          const y=ZF.y0+120+this.rng()*(ZF.y1-ZF.y0-260);
          this._bumper(x,y,10+this.rng()*6,0xffd84a);
        }
      }

      // ---------- spawn ----------
      _pickBallCount(maxBalls){
        if(!this.cfg.rndBalls) return maxBalls;
        const r=this.rng();
        if(maxBalls<=1) return 1;
        if(maxBalls===2) return (r<0.55)?1:2;
        if(r<0.45) return 1;
        if(r<0.80) return 2;
        return 3;
      }
      _pickBallType(){
        if(!this.cfg.rndSize) return {radius:14,density:0.0022,restitution:1.23};
        const c=this.cfg.chaos;
        const r=this.rng();
        const giant=0.02 + c*0.01;
        const large=0.20 + c*0.03;
        const small=0.25 + c*0.02;
        if(r<giant) return {radius:23,density:0.0039,restitution:1.06};
        if(r<giant+large) return {radius:18,density:0.0031,restitution:1.10};
        if(r<giant+large+small) return {radius:12,density:0.0018,restitution:1.31};
        return {radius:14,density:0.0022,restitution:1.23};
      }

      _spawnPlayers(){
        const maxPlayers=clamp(this.cfg.maxPlayers,2,20);
        let pool=(this.cfg.names && this.cfg.names.length) ? this.cfg.names.slice() : Array.from({length:maxPlayers},(_,i)=>`P${i+1}`);
        let chosen=pool.slice(0,maxPlayers);

        if(this.cfg.rndPlayers && pool.length>2){
          const size=2 + Math.floor(this.rng()*(maxPlayers-1));
          for(let i=pool.length-1;i>0;i--){
            const j=Math.floor(this.rng()*(i+1));
            [pool[i],pool[j]]=[pool[j],pool[i]];
          }
          chosen=pool.slice(0,size);
        }

        const colors=[
          0x7cfffb,0xff6bd6,0xffd84a,0x2cff9a,0xb38bff,0xff8a4a,0x6f7cff,
          0xff4d6d,0x4dff88,0x4d7dff,0xfff04d,0x8a4dff,0x4dfff0,0xff4df0,
          0xaaff4d,0x4dffaa,0xffaa4d,0xaa4dff,0x4daaff,0xffffff
        ];

        const startY=80;
        const span=W-2*WALL-180;

        for(let i=0;i<chosen.length;i++){
          const count=this._pickBallCount(clamp(this.cfg.maxBalls,1,3));
          for(let k=0;k<count;k++){
            const t=this._pickBallType();
            const x=WALL+90 + (i/Math.max(1,chosen.length-1))*span + (this.rng()-0.5)*22 + (k-0.5)*10;
            const y=startY - k*22;
            const col=colors[i%colors.length];

            const ball=this.add.circle(x,y,t.radius,col,0.22).setStrokeStyle(3,col,0.88);
            this.matter.add.gameObject(ball,{
              shape:{type:'circle',radius:t.radius},
              label:'ball',
              friction:0.002,
              frictionAir:0.003,
              restitution:t.restitution,
              density:t.density
            });
            ball.setVelocity((this.rng()-0.5)*2.2, 0.6+this.rng()*0.7);
            ball._done=false;
            ball._name=chosen[i];
            ball._trail=[];

            let txt=null;
            if(this.cfg.showNames){
              txt=this.add.text(x,y,chosen[i],{
                fontSize:'16px',fontStyle:'900',color:'#ffffff',
                stroke:'#000000',strokeThickness:6
              }).setOrigin(0.5,1).setDepth(40);
            }
            this.balls.push(ball);
            this.labels.push(txt);
          }
        }
        this.total=this.balls.length;
      }

      // ---------- bombs & final event ----------
      _bombShockwave(x,y){
        const p=this.add.particles(0xffffff).setDepth(70);
        p.createEmitter({
          x,y, speed:{min:90,max:360}, angle:{min:0,max:360},
          lifespan:520, quantity:28,
          scale:{start:0.7,end:0}, alpha:{start:0.85,end:0}
        });
        this.time.delayedCall(260, ()=>p.destroy());

        const g=this.add.graphics().setDepth(71);
        let r=10, a=0.65;
        this.time.addEvent({
          delay:16, repeat:18, callback:()=>{
            g.clear();
            g.lineStyle(8,0xff6bd6,a);
            g.strokeCircle(x,y,r);
            r+=16; a*=0.90;
          },
          onComplete:()=>g.destroy()
        });

        for(const s of this.balls){
          if(s._done) continue;
          const b=s.body;
          const dx=b.position.x-x, dy=b.position.y-y;
          const d=Math.max(40, Math.hypot(dx,dy));
          if(d<340){
            const k=(1 - d/340)*0.0026;
            b.force.x += (dx/d)*k*280;
            b.force.y += (dy/d)*k*260;
          }
        }
      }

      _finalEvent(){
        this.finalEventFired=true;
        const roll=this.rng();
        let msg='FINAL: (NO EVENT)';
        if(roll<0.40){
          // none
        }else if(roll<0.65){
          msg='FINAL: ACCEL';
          this.matter.world.setGravity(0,1.30);
          this.time.delayedCall(2200, ()=>this.matter.world.setGravity(0,1.12));
        }else if(roll<0.80){
          msg='FINAL: SHOCKWAVE';
          this._bombShockwave(W/2, ZF.y0+240);
        }else{
          msg='FINAL: STICKY';
          for(const s of this.balls){
            if(!s._done && s.y>ZF.y0-260 && s.y<ZF.y1) s.setFrictionAir(0.022);
          }
          this.time.delayedCall(2000, ()=>{
            for(const s of this.balls){ if(!s._done) s.setFrictionAir(0.003); }
          });
        }
        this._announce(msg);
      }

      _updateHUD(){
        const t=(performance.now()-this.startAt)/1000;
        const alive=this.total-this.finished;

        const ongoing=this.balls.filter(s=>!s._done).sort((a,b)=>b.y-a.y);
        const top=ongoing.slice(0,8).map(s=>s._name).join(', ');

        const mode=['AVG','LEAD','LAST','CHAOS'][this.camMode];

        const text =
          `ì§„í–‰: <b>${this.finished}</b> / ${this.total} (ë‚¨ìŒ ${alive})<br>`+
          `ê²½ê³¼: ${t.toFixed(1)}s Â· CAM: <b>${mode}</b> Â· ZOOM: ${this.autoZoom?'AUTO':'LOCK'}<br>`+
          `ì„ ë‘ê¶Œ: ${top || 'â€”'}<br>`+
          `ìµœì¢…: Y ë¶„ê¸° + íšŒì „ ë£°ë › + ì¢Œ/ìš° ê²Œì´íŠ¸`;

        document.getElementById('hud').innerHTML=text;
        document.getElementById('miniHud').textContent=`${this.finished}/${this.total} Â· ${t.toFixed(1)}s Â· ${mode}`;
      }
    }

    // ---------- boot ----------
    let game=null;

    function getCfg(){
      return {
        names: parseNames(document.getElementById('names').value),
        maxPlayers: parseInt(document.getElementById('maxPlayers').value,10)||20,
        maxBalls: parseInt(document.getElementById('maxBalls').value,10)||2,
        chaos: clamp(parseInt(document.getElementById('chaos').value,10)||3,0,5),
        seed: parseInt(document.getElementById('seed').value,10)||12345,
        rndPlayers: document.getElementById('rndPlayers').checked,
        rndBalls: document.getElementById('rndBalls').checked,
        rndSize: document.getElementById('rndSize').checked,
        showNames: document.getElementById('showNames').checked,
        autoZoom: document.getElementById('autoZoom').checked
      };
    }

    function start(){
      if (typeof Phaser === 'undefined'){
        showErr('âš ï¸ Phaser ë¡œë”© ì‹¤íŒ¨ë¡œ ì‹œì‘í•  ìˆ˜ ì—†ì–´. CDNì´ ë§‰íŒ í™˜ê²½ì´ë©´ ë¡œì»¬ phaser íŒŒì¼ì´ í•„ìš”í•´.');
        return;
      }
      const cfg=getCfg();
      if(game){ game.destroy(true); game=null; }

      game=new Phaser.Game({
        type: Phaser.AUTO,
        backgroundColor:'#05060b',
        width: window.innerWidth,
        height: window.innerHeight,
        physics:{
          default:'matter',
          matter:{ gravity:{y:1.12}, enableSleep:true, debug:false }
        },
        scene:[ new Main() ]
      });
      game.scene.start('main',{cfg});
    }

    function newSeed(){
      document.getElementById('seed').value = 1 + Math.floor(Math.random()*999999);
    }

    // UI fold
    const panel=document.getElementById('panel');
    const mini=document.getElementById('mini');
    document.getElementById('toggleBtn').addEventListener('click', ()=>{
      panel.style.display='none';
      mini.style.display='block';
    }, {passive:true});
    document.getElementById('openBtn').addEventListener('click', ()=>{
      panel.style.display='block';
      mini.style.display='none';
    }, {passive:true});

    // Start buttons (touch-safe)
    document.getElementById('startBtn').addEventListener('click', start, {passive:true});
    document.getElementById('startBtn2').addEventListener('click', start, {passive:true});
    document.getElementById('seedBtn').addEventListener('click', newSeed, {passive:true});

    // Auto-start once after load (ëª¨ë°”ì¼ì—ì„œ ë²„íŠ¼ ëª» ëˆ„ë¥´ëŠ” ìƒí™© ëŒ€ë¹„)
    window.addEventListener('load', ()=>{
      // ì ê¹ ê¸°ë‹¤ë ¸ë‹¤ê°€ ì‹œì‘ (DOM ì•ˆì •)
      setTimeout(()=>start(), 50);
    }, {passive:true});
  </script>
</body>
</html>
