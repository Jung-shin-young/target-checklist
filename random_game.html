<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Chaos Drop Royale (Prototype)</title>
  <style>
    html,body{margin:0;height:100%;background:#0b0b10;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto}
    #ui{
      position:fixed;top:10px;left:10px;z-index:10;
      background:rgba(20,20,30,.85);border:1px solid rgba(255,255,255,.12);
      padding:10px 12px;border-radius:14px;backdrop-filter: blur(6px);
      width:min(420px, calc(100vw - 20px));
    }
    #ui h1{font-size:14px;margin:0 0 8px 0;opacity:.95}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:6px 0}
    label{font-size:12px;opacity:.9;display:flex;align-items:center;gap:6px}
    input[type="number"]{width:76px;padding:6px 8px;border-radius:10px;border:1px solid rgba(255,255,255,.18);background:#0f1220;color:#eee}
    input[type="checkbox"]{transform:scale(1.05)}
    button{
      padding:8px 10px;border-radius:12px;border:1px solid rgba(255,255,255,.18);
      background:#14182a;color:#fff;cursor:pointer;font-weight:600
    }
    button:hover{filter:brightness(1.1)}
    #hud{font-size:12px;opacity:.9;margin-top:6px;line-height:1.4}
    #hint{font-size:11px;opacity:.7;margin-top:6px}
    canvas{display:block}
  </style>
</head>
<body>
  <div id="ui">
    <h1>ğŸ° Chaos Drop Royale â€” ì„¸ë¡œ ë‚™í•˜í˜• (ê³µí‰+ì ë‹¹ë°˜ì „)</h1>

    <div class="row">
      <label>ì¸ì›(2~20)
        <input id="players" type="number" min="2" max="20" value="12">
      </label>
      <label>ìµœëŒ€ ê³µ/ì¸
        <input id="maxBalls" type="number" min="1" max="3" value="2">
      </label>
      <label>ì‹œë“œ
        <input id="seed" type="number" min="1" max="999999" value="12345">
      </label>
    </div>

    <div class="row">
      <label><input id="rndPlayers" type="checkbox">ì¸ì› ëœë¤</label>
      <label><input id="rndBalls" type="checkbox" checked>ê³µ ìˆ˜ ëœë¤</label>
      <label><input id="rndSize" type="checkbox" checked>í¬ê¸°/ë¬´ê²Œ ëœë¤</label>
      <label><input id="showNames" type="checkbox" checked>ì´ë¦„ í‘œì‹œ</label>
    </div>

    <div class="row">
      <label>í˜¼ëˆ ë ˆë²¨(0~5)
        <input id="chaos" type="number" min="0" max="5" value="3">
      </label>
      <button id="startBtn">START</button>
      <button id="resetBtn">RESET</button>
    </div>

    <div id="hud">ëŒ€ê¸°ì¤‘â€¦</div>
    <div id="hint">íŒ: í™”ë©´ì€ ë‚¨ì€ ê³µë“¤ì˜ â€œí‰ê·  ìœ„ì¹˜â€ë¥¼ ë”°ë¼ê°€ì„œ 60~80ì´ˆ ì •ë„ ê³„ì† ë°•í„°ì§€ê²Œ ì›€ì§ì„.</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
  <script>
    // ---------- tiny deterministic RNG (mulberry32) ----------
    function mulberry32(a){
      return function(){
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      }
    }
    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));

    // ---------- game constants ----------
    const W = 720;
    const VIEW_H = 900;     // viewport height (camera follows)
    const WORLD_H = 5200;   // tall vertical world
    const WALL = 24;

    // zones (y ranges)
    const Z1 = {y0: 120,  y1: 1550};  // bumper storm
    const Z2 = {y0: 1550, y1: 2900};  // branching + moving gates
    const Z3 = {y0: 2900, y1: 3900};  // rotating wheel + chaos ring
    const Z4 = {y0: 3900, y1: 4600};  // blackholes + gravity flip
    const ZF = {y0: 4600, y1: 5050};  // final chaos gate + goal

    // fairness philosophy: no rubber-band, just "final zone events" with moderate probability.
    // ---------- Phaser Scene ----------
    class Main extends Phaser.Scene {
      constructor(){ super('main'); }

      init(data){
        this.cfg = data.cfg;
        this.rng = mulberry32(this.cfg.seed|0);
        this.balls = [];
        this.labels = [];
        this.finished = 0;
        this.total = 0;
        this.startAt = 0;
        this.finalEventFired = false;
        this.gravityFlipped = false;
      }

      preload(){}

      create(){
        const scene = this;

        // Matter world tuning for "dynamic bumpiness"
        this.matter.world.setBounds(0, 0, W, WORLD_H, 64, true, true, false, true);
        this.matter.world.engine.positionIterations = 8;
        this.matter.world.engine.velocityIterations = 6;
        this.matter.world.engine.constraintIterations = 2;

        // default gravity (down)
        this.matter.world.setGravity(0, 1.08);

        // background grid-ish
        const g = this.add.graphics();
        g.lineStyle(1, 0x1e2236, 0.5);
        for(let y=0;y<=WORLD_H;y+=80){
          g.beginPath(); g.moveTo(0,y); g.lineTo(W,y); g.strokePath();
        }
        for(let x=0;x<=W;x+=80){
          g.beginPath(); g.moveTo(x,0); g.lineTo(x,WORLD_H); g.strokePath();
        }
        g.setDepth(-10);

        // walls
        this._staticRect(WALL/2, WORLD_H/2, WALL, WORLD_H, {label:'wall'});
        this._staticRect(W - WALL/2, WORLD_H/2, WALL, WORLD_H, {label:'wall'});

        // core map build
        this._buildZone1();
        this._buildZone2();
        this._buildZone3();
        this._buildZone4();
        this._buildFinalZone();

        // finish sensor
        this.finishLine = this.matter.add.rectangle(W/2, WORLD_H-80, W-2*WALL-40, 16, {
          isStatic:true, isSensor:true, label:'finish'
        });
        this.add.rectangle(W/2, WORLD_H-80, W-2*WALL-40, 16, 0x2cff9a, 0.10).setStrokeStyle(1,0x2cff9a,0.25);

        // camera
        this.cameras.main.setBounds(0,0,W,WORLD_H);
        this.cameras.main.setViewport(0,0,window.innerWidth,window.innerHeight);
        this.scale.on('resize', (gs)=>{
          this.cameras.main.setViewport(0,0,gs.width,gs.height);
        });

        // collisions / sensors
        this.matter.world.on('collisionstart', (evt)=>{
          for (const pair of evt.pairs){
            const a = pair.bodyA;
            const b = pair.bodyB;
            if ((a.label==='finish' && b.label==='ball') || (b.label==='finish' && a.label==='ball')){
              const ballBody = (a.label==='ball') ? a : b;
              const spr = ballBody.gameObject;
              if (spr && !spr._done){
                spr._done = true;
                this.finished++;
                // pop effect
                const fx = this.add.circle(spr.x, spr.y, spr.displayWidth*0.35, 0xffffff, 0.18);
                this.tweens.add({targets:fx, scale:3, alpha:0, duration:420, onComplete:()=>fx.destroy()});
                // freeze + fade
                spr.setVelocity(0,0);
                spr.setStatic(true);
                this.tweens.add({targets:spr, alpha:0.25, duration:250});
              }
            }
          }
        });

        // spawn players + balls
        this._spawnAll();

        this.startAt = performance.now();

        // HUD update timer
        this.time.addEvent({
          delay: 120, loop:true, callback: ()=> this._updateHUD()
        });

        // gentle "final event" trigger window (moderate, not always)
        // fires once when (time>55s) AND (some balls are near final zone)
        this.time.addEvent({
          delay: 250, loop:true, callback: ()=>{
            const t = (performance.now() - this.startAt)/1000;
            if (!this.finalEventFired && t > 55){
              const nearFinal = this.balls.some(s=>!s._done && s.y > ZF.y0-180);
              if (nearFinal){
                this._fireFinalEvent();
              }
            }
            // gravity flip once in Z4 window, not guaranteed
            if (!this.gravityFlipped && t > 48){
              // 30% chance to flip sideways briefly
              if (this.rng() < 0.30){
                this.gravityFlipped = true;
                this._gravitySideFlip();
              } else {
                this.gravityFlipped = true; // mark as decided (no more checks)
              }
            }
          }
        });
      }

      update(){
        // camera follow average position of "alive" balls
        let sumY=0, n=0;
        for (const s of this.balls){
          if (!s._done){
            sumY += s.y; n++;
          }
        }
        if (n>0){
          const avgY = sumY/n;
          const targetY = clamp(avgY - VIEW_H*0.35, 0, WORLD_H - VIEW_H);
          this.cameras.main.scrollY = Phaser.Math.Linear(this.cameras.main.scrollY, targetY, 0.08);
        }

        // labels follow
        if (this.cfg.showNames){
          for (let i=0;i<this.balls.length;i++){
            const s = this.balls[i];
            const txt = this.labels[i];
            if (!txt) continue;
            txt.setPosition(s.x, s.y - s.displayHeight*0.7);
            txt.setVisible(!s._done);
          }
        }
      }

      // ---------- map builders ----------
      _staticRect(x,y,w,h, opt={}){
        const body = this.matter.add.rectangle(x,y,w,h,{
          isStatic:true,
          friction:0.02,
          restitution:0.9,
          label: opt.label || 'static'
        });
        const col = opt.color ?? 0x6f7cff;
        const alpha = opt.alpha ?? 0.10;
        const r = this.add.rectangle(x,y,w,h,col,alpha);
        r.setStrokeStyle(1,col,0.15);
        r.setDepth(-2);
        r._body = body;
        return {body, rect:r};
      }

      _bumper(x,y,r, strength=0.015){
        const body = this.matter.add.circle(x,y,r,{
          isStatic:true,
          restitution: 1.25,
          friction: 0.001,
          label:'bumper'
        });
        // visual
        const c = this.add.circle(x,y,r,0xffd84a,0.08).setStrokeStyle(1,0xffd84a,0.22);
        c.setDepth(-1);

        // tiny "kick" sensor ring (makes it feel more arcade)
        const sensor = this.matter.add.circle(x,y,r+10,{isStatic:true,isSensor:true,label:'bumperSensor'});
        this.matter.world.on('collisionstart', (evt)=>{
          for (const p of evt.pairs){
            const a=p.bodyA, b=p.bodyB;
            if ((a===sensor && b.label==='ball') || (b===sensor && a.label==='ball')){
              const ball = (b.label==='ball') ? b : a;
              const dx = ball.position.x - x;
              const dy = ball.position.y - y;
              const mag = Math.max(1, Math.hypot(dx,dy));
              // push outwards a bit
              const vx = (dx/mag) * (strength*800);
              const vy = (dy/mag) * (strength*800);
              ball.force.x += vx;
              ball.force.y += vy;
            }
          }
        });
      }

      _movingGate(x,y,w,h, dx, periodMs){
        const body = this.matter.add.rectangle(x,y,w,h,{
          isStatic:true, restitution:1.05, friction:0.01, label:'gate'
        });
        const r = this.add.rectangle(x,y,w,h,0xff6bd6,0.10).setStrokeStyle(1,0xff6bd6,0.2).setDepth(-1);
        const t0 = performance.now();
        this.time.addEvent({
          delay: 16, loop:true, callback: ()=>{
            const t = (performance.now()-t0)/periodMs * Math.PI*2;
            const nx = x + Math.sin(t)*dx;
            this.matter.body.setPosition(body,{x:nx,y:y});
            r.setPosition(nx,y);
          }
        });
      }

      _rotor(x,y,r, speed){
        const body = this.matter.add.circle(x,y,r,{
          isStatic:true, restitution:1.15, friction:0.002, label:'rotor'
        });
        const ring = this.add.circle(x,y,r,0x7cfffb,0.06).setStrokeStyle(1,0x7cfffb,0.20).setDepth(-1);

        // "spin kick": apply tangential force when ball close
        const sensor = this.matter.add.circle(x,y,r+26,{isStatic:true,isSensor:true,label:'rotorSensor'});
        this.matter.world.on('collisionstart', (evt)=>{
          for (const p of evt.pairs){
            const a=p.bodyA, b=p.bodyB;
            if ((a===sensor && b.label==='ball') || (b===sensor && a.label==='ball')){
              const ball = (b.label==='ball') ? b : a;
              const dx = ball.position.x - x;
              const dy = ball.position.y - y;
              const mag = Math.max(1, Math.hypot(dx,dy));
              // tangential direction
              const tx = -dy/mag;
              const ty = dx/mag;
              ball.force.x += tx * speed;
              ball.force.y += ty * speed;
            }
          }
        });

        // ring pulse
        this.tweens.add({targets:ring, alpha: {from:0.04, to:0.10}, duration:800, yoyo:true, repeat:-1});
      }

      _blackHole(x,y,r, pull){
        const sensor = this.matter.add.circle(x,y,r,{isStatic:true,isSensor:true,label:'hole'});
        const c = this.add.circle(x,y,r,0x000000,0.25).setStrokeStyle(1,0xb38bff,0.25).setDepth(-1);

        // continuous pulling
        this.time.addEvent({
          delay:16, loop:true, callback: ()=>{
            for (const s of this.balls){
              if (s._done) continue;
              const b = s.body;
              if (!b) continue;
              const dx = x - b.position.x;
              const dy = y - b.position.y;
              const d = Math.hypot(dx,dy);
              if (d < r*2.1){
                const k = (1 - d/(r*2.1)) * pull;
                b.force.x += (dx/d) * k;
                b.force.y += (dy/d) * k;
              }
            }
          }
        });

        // if swallowed (very close), teleport upward a bit (not too crazy)
        this.time.addEvent({
          delay:80, loop:true, callback: ()=>{
            for (const s of this.balls){
              if (s._done) continue;
              const b=s.body;
              const d = Math.hypot(x-b.position.x, y-b.position.y);
              if (d < r*0.45){
                // moderate "re-shuffle": send to a random earlier lane in Z3/Z2
                const tx = WALL + 60 + this.rng()*(W - 2*WALL - 120);
                const ty = Z3.y0 + 80 + this.rng()*(Z3.y1 - Z3.y0 - 200);
                this.matter.body.setPosition(b,{x:tx,y:ty});
                this.matter.body.setVelocity(b,{x:(this.rng()-0.5)*4, y:(this.rng()-0.5)*2});
              }
            }
          }
        });

        return {sensor, c};
      }

      _buildZone1(){
        // Dense bumper storm
        const chaos = this.cfg.chaos;
        const cols = 9;
        const rows = 14 + chaos*2;
        const xMin = WALL+50, xMax=W-WALL-50;
        const yMin = Z1.y0+90, yMax = Z1.y1-60;

        for(let r=0;r<rows;r++){
          const y = Phaser.Math.Linear(yMin,yMax, r/(rows-1));
          for(let c=0;c<cols;c++){
            const x = Phaser.Math.Linear(xMin,xMax, c/(cols-1)) + ((r%2)*18) + (this.rng()-0.5)*8;
            if (this.rng() < 0.78) this._bumper(x,y, 10 + this.rng()*6, 0.010 + chaos*0.001);
          }
        }

        // some angled deflectors
        for(let i=0;i<10+chaos*2;i++){
          const x = xMin + this.rng()*(xMax-xMin);
          const y = yMin + this.rng()*(yMax-yMin);
          const w = 120 + this.rng()*70;
          const h = 14;
          const angle = (this.rng()<0.5 ? -1 : 1) * (0.25 + this.rng()*0.5);
          const body = this.matter.add.rectangle(x,y,w,h,{
            isStatic:true, restitution:1.1, friction:0.002, angle, label:'deflector'
          });
          const rect = this.add.rectangle(x,y,w,h,0x7cfffb,0.06).setStrokeStyle(1,0x7cfffb,0.14).setDepth(-2);
          rect.rotation = angle;
        }
      }

      _buildZone2(){
        // Branching lanes with gates
        const laneW = (W - 2*WALL - 40)/3;
        const y0 = Z2.y0 + 40, y1 = Z2.y1 - 40;

        // separators
        for(let i=1;i<=2;i++){
          this._staticRect(WALL+20 + laneW*i, (y0+y1)/2, 10, (y1-y0), {color:0x6f7cff, alpha:0.08});
        }

        // gates (moving blockers)
        for(let i=0;i<7+this.cfg.chaos;i++){
          const lane = Math.floor(this.rng()*3);
          const x = WALL+20 + laneW*lane + laneW/2;
          const y = y0 + this.rng()*(y1-y0);
          const w = laneW*0.62;
          const h = 16;
          const dx = 70 + this.rng()*60;
          const period = 900 + this.rng()*700;
          this._movingGate(x,y,w,h,dx,period);
        }

        // bumpers sprinkled
        for(let i=0;i<22+this.cfg.chaos*5;i++){
          const x = WALL+50 + this.rng()*(W-2*WALL-100);
          const y = y0 + this.rng()*(y1-y0);
          this._bumper(x,y, 10+this.rng()*6, 0.012);
        }
      }

      _buildZone3(){
        // Rotating influence zone
        const yMid = (Z3.y0 + Z3.y1)/2;

        // big rotor in center + two side rotors
        this._rotor(W/2, yMid, 54, 0.00085);
        this._rotor(W*0.27, yMid-260, 40, 0.00070);
        this._rotor(W*0.73, yMid+240, 40, -0.00072);

        // "pinball pins" rows
        for(let i=0;i<70+this.cfg.chaos*10;i++){
          const x = WALL+50 + this.rng()*(W-2*WALL-100);
          const y = Z3.y0+80 + this.rng()*(Z3.y1 - Z3.y0 - 160);
          this._bumper(x,y, 9+this.rng()*5, 0.010);
        }
      }

      _buildZone4(){
        // Blackholes + (optional) gravity side flip later
        const y0 = Z4.y0+60, y1 = Z4.y1-80;
        const holes = 2 + (this.cfg.chaos>=4 ? 1 : 0);
        for(let i=0;i<holes;i++){
          const x = WALL+120 + this.rng()*(W-2*WALL-240);
          const y = y0 + this.rng()*(y1-y0);
          this._blackHole(x,y, 46 + this.rng()*16, 0.00045 + this.cfg.chaos*0.00008);
        }

        // some tight funnels
        for(let i=0;i<6;i++){
          const y = y0 + (i/5)*(y1-y0);
          const x = W/2 + (this.rng()-0.5)*120;
          const w = 220, h = 14;
          const a = (this.rng()<0.5?-1:1)*(0.22+this.rng()*0.25);
          const body = this.matter.add.rectangle(x,y,w,h,{isStatic:true,restitution:1.05,friction:0.003,angle:a,label:'funnel'});
          const rect = this.add.rectangle(x,y,w,h,0xb38bff,0.06).setStrokeStyle(1,0xb38bff,0.16).setDepth(-2);
          rect.rotation=a;
        }
      }

      _buildFinalZone(){
        // final chaos gate visuals + mild deflectors
        const y0 = ZF.y0+40, y1 = ZF.y1-120;

        // narrowing corridor
        this._staticRect(WALL+80, (y0+y1)/2, 12, (y1-y0), {color:0x2cff9a, alpha:0.08});
        this._staticRect(W- (WALL+80), (y0+y1)/2, 12, (y1-y0), {color:0x2cff9a, alpha:0.08});

        // last bumpers (not too many, keeps "meaning" of mid race)
        for(let i=0;i<18+this.cfg.chaos*3;i++){
          const x = WALL+110 + this.rng()*(W-2*WALL-220);
          const y = y0 + this.rng()*(y1-y0);
          this._bumper(x,y, 10+this.rng()*6, 0.010);
        }

        // goal mouth
        this._staticRect(W/2, WORLD_H-40, W-2*WALL-160, 18, {color:0x2cff9a, alpha:0.10});
      }

      // ---------- spawning ----------
      _pickBallCount(maxBalls){
        if (!this.cfg.rndBalls) return maxBalls;
        // fair distribution, public probabilities (no hidden advantage)
        const r = this.rng();
        if (maxBalls<=1) return 1;
        if (maxBalls===2) return (r < 0.55) ? 1 : 2;
        // maxBalls===3
        if (r < 0.45) return 1;
        if (r < 0.80) return 2;
        return 3;
      }

      _pickBallType(){
        if (!this.cfg.rndSize){
          return {radius:14, density:0.0022, restitution:1.20};
        }
        // chaos affects "extremes" a bit, but still equal for everyone
        const c = this.cfg.chaos;
        const r = this.rng();
        const giantChance = 0.02 + c*0.01; // up to ~7%
        const largeChance = 0.20 + c*0.03; // up to ~35%
        const smallChance = 0.25 + c*0.02; // up to ~35%

        if (r < giantChance){
          return {radius:22, density:0.0036, restitution:1.05}; // heavy, pushy, less bouncy
        } else if (r < giantChance + largeChance){
          return {radius:18, density:0.0030, restitution:1.10};
        } else if (r < giantChance + largeChance + smallChance){
          return {radius:12, density:0.0018, restitution:1.28}; // fast/bouncy
        } else {
          return {radius:14, density:0.0022, restitution:1.20};
        }
      }

      _spawnAll(){
        let p = clamp(this.cfg.players,2,20);
        if (this.cfg.rndPlayers){
          // fair random: uniform 2..players
          p = 2 + Math.floor(this.rng() * (this.cfg.players - 1));
        }
        const maxBalls = clamp(this.cfg.maxBalls,1,3);

        const palette = [
          0x7cfffb,0xff6bd6,0xffd84a,0x2cff9a,0xb38bff,0xff8a4a,0x6f7cff,
          0xff4d6d,0x4dff88,0x4d7dff,0xfff04d,0x8a4dff,0x4dfff0,0xff4df0,
          0xaaff4d,0x4dffaa,0xffaa4d,0xaa4dff,0x4daaff,0xffffff
        ];

        const startY = 60;
        const span = W - 2*WALL - 120;

        let idx=0;
        for(let i=0;i<p;i++){
          const ballsForPlayer = this._pickBallCount(maxBalls);
          for(let k=0;k<ballsForPlayer;k++){
            const t = this._pickBallType();
            const x = WALL + 60 + ( (i/(p-1||1))*span ) + (this.rng()-0.5)*26 + (k-0.5)*10;
            const y = startY - k*20;
            const color = palette[i % palette.length];

            const s = this.add.circle(x,y,t.radius,color,0.18).setStrokeStyle(2,color,0.55);
            this.matter.add.gameObject(s, {
              shape: {type:'circle', radius:t.radius},
              label:'ball',
              friction: 0.002,
              frictionAir: 0.003,
              restitution: t.restitution,
              density: t.density
            });

            // stronger collisions vibe
            s.setBounce(t.restitution);
            s.setFriction(0.004);
            s.setVelocity((this.rng()-0.5)*2.2, 0.2 + this.rng()*0.6);
            s._done = false;
            s._player = i+1;
            s._ballIndex = k+1;

            this.balls.push(s);

            if (this.cfg.showNames){
              const name = `P${i+1}${ballsForPlayer>1?`-${k+1}`:''}`;
              const txt = this.add.text(x,y, name, {fontSize:'11px', color:'#ffffff'}).setAlpha(0.85);
              txt.setDepth(5);
              this.labels.push(txt);
            } else {
              this.labels.push(null);
            }

            idx++;
          }
        }

        this.total = this.balls.length;
      }

      // ---------- events ----------
      _fireFinalEvent(){
        // Moderate: not always a big flip.
        this.finalEventFired = true;

        const roll = this.rng();
        let msg = 'FINAL: (ì•„ë¬´ ì¼ ì—†ìŒ)';
        if (roll < 0.40){
          // nothing
        } else if (roll < 0.65){
          // small global accel downward (keeps race meaningful)
          msg = 'FINAL: ì „ì› ê°€ì†';
          this.matter.world.setGravity(0, 1.22);
          this.time.delayedCall(2500, ()=> this.matter.world.setGravity(0, 1.08));
        } else if (roll < 0.80){
          // mild shockwave near final gate
          msg = 'FINAL: ì¶©ê²©íŒŒ';
          const cx = W/2, cy = ZF.y0 + 180;
          for (const s of this.balls){
            if (s._done) continue;
            if (s.y < ZF.y0-220 || s.y > ZF.y1) continue;
            const b = s.body;
            const dx = b.position.x - cx;
            const dy = b.position.y - cy;
            const d = Math.max(1, Math.hypot(dx,dy));
            const k = (1 - Math.min(1, d/260)) * 0.0022;
            b.force.x += (dx/d)*k*320;
            b.force.y += (dy/d)*k*260;
          }
        } else if (roll < 0.90){
          // swap positions of 2 random balls that are both in final area (rare-ish)
          msg = 'FINAL: ìœ„ì¹˜ êµì²´(2ê°œ)';
          const candidates = this.balls.filter(s=>!s._done && s.y > ZF.y0-120 && s.y < ZF.y1-40);
          if (candidates.length >= 2){
            const a = candidates[Math.floor(this.rng()*candidates.length)];
            let b = candidates[Math.floor(this.rng()*candidates.length)];
            if (a===b) b = candidates[(candidates.indexOf(a)+1)%candidates.length];
            const pa = {x:a.body.position.x, y:a.body.position.y};
            const pb = {x:b.body.position.x, y:b.body.position.y};
            this.matter.body.setPosition(a.body,pb);
            this.matter.body.setPosition(b.body,pa);
          } else {
            msg = 'FINAL: (êµì²´ ì‹¤íŒ¨â†’ì—†ìŒ)';
          }
        } else {
          // very rare: small temporary drag increase (like "sticky")
          msg = 'FINAL: ëˆì ì¡´(ì ê¹)';
          for (const s of this.balls){
            if (s._done) continue;
            if (s.y > ZF.y0-220 && s.y < ZF.y1){
              s.setFrictionAir(0.018);
            }
          }
          this.time.delayedCall(2200, ()=>{
            for (const s of this.balls){ if(!s._done) s.setFrictionAir(0.003); }
          });
        }

        this._announce(msg);
      }

      _gravitySideFlip(){
        // Side gravity for a moment (rare). Not a guaranteed flip.
        this._announce('EVENT: ì¤‘ë ¥ ì¢Œìš° í”ë“¤ë¦¼');
        const dir = (this.rng()<0.5 ? -1 : 1);
        this.matter.world.setGravity(0.55*dir, 0.92);
        this.time.delayedCall(2200, ()=> this.matter.world.setGravity(0, 1.08));
      }

      _announce(text){
        const t = this.add.text(W/2, this.cameras.main.scrollY + 70, text, {
          fontSize:'18px', color:'#ffffff', fontStyle:'700'
        }).setOrigin(0.5).setAlpha(0.0).setDepth(20);
        this.tweens.add({targets:t, alpha:1, duration:200, yoyo:true, hold:1200,
          onComplete:()=>t.destroy()
        });
      }

      _updateHUD(){
        const elapsed = (performance.now() - this.startAt)/1000;
        const alive = this.total - this.finished;
        const hud = document.getElementById('hud');

        // rough "rank": by max Y (lower is behind). show top 5 by progress
        const ongoing = this.balls.filter(s=>!s._done);
        ongoing.sort((a,b)=> b.y - a.y);
        const top = ongoing.slice(0,5).map(s=>`P${s._player}${(s._ballIndex?`-${s._ballIndex}`:'')}`).join(', ');

        hud.innerHTML =
          `ì§„í–‰: <b>${this.finished}</b> / ${this.total}  (ë‚¨ìŒ ${alive})<br>`+
          `ê²½ê³¼: ${elapsed.toFixed(1)}s<br>`+
          `ì„ ë‘ê¶Œ(ëŒ€ì¶©): ${top || 'â€”'}<br>`+
          `FINAL ì´ë²¤íŠ¸: ${this.finalEventFired ? 'ë°œë™ë¨' : 'ëŒ€ê¸°ì¤‘'}`;
      }
    }

    // ---------- boot / UI handlers ----------
    let game = null;

    function startGame(){
      const cfg = {
        players: parseInt(document.getElementById('players').value,10) || 12,
        maxBalls: parseInt(document.getElementById('maxBalls').value,10) || 2,
        seed: parseInt(document.getElementById('seed').value,10) || 12345,
        rndPlayers: document.getElementById('rndPlayers').checked,
        rndBalls: document.getElementById('rndBalls').checked,
        rndSize: document.getElementById('rndSize').checked,
        showNames: document.getElementById('showNames').checked,
        chaos: clamp(parseInt(document.getElementById('chaos').value,10) || 3, 0, 5),
      };

      if (game) { game.destroy(true); game = null; }

      game = new Phaser.Game({
        type: Phaser.AUTO,
        parent: document.body,
        backgroundColor: '#0b0b10',
        width: window.innerWidth,
        height: window.innerHeight,
        physics: {
          default: 'matter',
          matter: {
            gravity: { y: 1.08 },
            enableSleep: true,
            debug: false
          }
        },
        scene: [ new Main() ]
      });

      game.scene.start('main', { cfg });
    }

    function resetSeed(){
      const v = 1 + Math.floor(Math.random()*999999);
      document.getElementById('seed').value = v;
    }

    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('resetBtn').addEventListener('click', resetSeed);

    // auto-start once
    startGame();
  </script>
</body>
</html>
