<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Marble Roulette Style v3 â€” Chaos Drop Royale</title>
  <style>
    html,body{margin:0;height:100%;background:#05060b;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto}
    canvas{display:block}

    #panel{
      position:fixed;left:14px;top:14px;z-index:20;
      width:min(480px, calc(100vw - 28px));
      background:rgba(10,12,20,.84);
      border:1px solid rgba(255,255,255,.14);
      border-radius:16px;
      box-shadow:0 10px 40px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }
    #panel header{
      display:flex;align-items:center;justify-content:space-between;
      padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.10);
    }
    #panel header .title{font-weight:900;font-size:13px;letter-spacing:.2px}
    #panel header .sub{font-size:11px;opacity:.75;margin-left:8px}
    #panel header .right{display:flex;gap:8px;align-items:center}
    #panel button{
      padding:7px 10px;border-radius:12px;border:1px solid rgba(255,255,255,.16);
      background:rgba(20,26,44,.9);color:#fff;cursor:pointer;font-weight:800
    }
    #panel button:hover{filter:brightness(1.12)}
    #body{padding:12px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .box{
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;padding:10px;background:rgba(255,255,255,.03)
    }
    .box h3{margin:0 0 8px 0;font-size:12px;opacity:.9}
    textarea{
      width:100%;min-height:96px;resize:vertical;
      padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,.14);
      background:#0b0f1f;color:#fff;font-size:12px;line-height:1.4
    }
    label{display:flex;gap:8px;align-items:center;font-size:12px;opacity:.9;margin:6px 0}
    input[type="number"]{
      width:92px;padding:6px 8px;border-radius:10px;border:1px solid rgba(255,255,255,.14);
      background:#0b0f1f;color:#fff
    }
    input[type="checkbox"]{transform:scale(1.1)}
    #hud{
      margin-top:10px;
      padding:10px;border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.25);
      font-size:12px;line-height:1.55;opacity:.94
    }
    #mini{
      position:fixed;left:14px;top:14px;z-index:21;display:none;
      padding:10px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.14);
      background:rgba(10,12,20,.84);backdrop-filter: blur(10px);
      box-shadow:0 10px 40px rgba(0,0,0,.45);
    }
    #mini .row{display:flex;gap:8px;align-items:center}
    #mini .txt{font-size:12px;font-weight:900}
    #mini .sub{font-size:11px;opacity:.7}
    kbd{
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas;
      font-size:11px;
      padding:2px 6px;border-radius:8px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.06)
    }
  </style>
</head>
<body>
  <div id="mini">
    <div class="row">
      <div>
        <div class="txt">ğŸ° Marble Drop v3</div>
        <div class="sub" id="miniHud">ëŒ€ê¸°ì¤‘</div>
      </div>
      <button id="openBtn">ì—´ê¸°</button>
      <button id="startBtn2">ì‹œì‘</button>
    </div>
  </div>

  <div id="panel">
    <header>
      <div>
        <span class="title">ğŸ° Marble Roulette Style v3</span>
        <span class="sub">ë¯¸ë‹ˆë§µ/íŠ¸ë ˆì¼/í­íƒ„/ìŠ¤í”¼ë„ˆ/ë¸”ë™í™€</span>
      </div>
      <div class="right">
        <button id="toggleBtn">ì ‘ê¸°</button>
        <button id="startBtn">START</button>
        <button id="seedBtn">SEED</button>
      </div>
    </header>

    <div id="body">
      <div class="grid">
        <div class="box">
          <h3>ì´ë¦„ ì…ë ¥ (ì½¤ë§ˆ/ì¤„ë°”ê¿ˆ OK, ê°€ì¤‘ì¹˜ *N ê°€ëŠ¥)</h3>
          <textarea id="names">ì§±êµ¬*5, ì§±ì•„*10, ë´‰ë¯¸ì„ *3</textarea>
          <div style="font-size:11px;opacity:.72;margin-top:6px">
            ë‹¨ì¶•í‚¤: <kbd>C</kbd> ì¹´ë©”ë¼ëª¨ë“œ, <kbd>Z</kbd> ì¤Œí† ê¸€
          </div>
        </div>

        <div class="box">
          <h3>ì˜µì…˜</h3>
          <label>ìµœëŒ€ ì¸ì›(2~20) <input id="maxPlayers" type="number" min="2" max="20" value="20"></label>
          <label>ìµœëŒ€ ê³µ/ì¸(1~3) <input id="maxBalls" type="number" min="1" max="3" value="2"></label>
          <label>í˜¼ëˆ ë ˆë²¨(0~5) <input id="chaos" type="number" min="0" max="5" value="3"></label>
          <label>ì‹œë“œ <input id="seed" type="number" min="1" max="999999" value="12345"></label>

          <label><input id="rndPlayers" type="checkbox" checked> ì¸ì› ëœë¤(ì…ë ¥ì—ì„œ ì¼ë¶€ë§Œ ë½‘ìŒ)</label>
          <label><input id="rndBalls" type="checkbox" checked> ê³µ ìˆ˜ ëœë¤</label>
          <label><input id="rndSize" type="checkbox" checked> í¬ê¸°/ë¬´ê²Œ ëœë¤</label>
          <label><input id="showNames" type="checkbox" checked> ì´ë¦„ í‘œì‹œ</label>
          <label><input id="autoZoom" type="checkbox" checked> ìë™ ì¤Œ</label>
        </div>
      </div>

      <div id="hud">ëŒ€ê¸°ì¤‘â€¦</div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
  <script>
    // ---------- deterministic RNG ----------
    function mulberry32(a){
      return function(){
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      }
    }
    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));

    // ---------- parse names (comma/newline, allow *N) ----------
    function parseNames(raw){
      const parts = raw.replace(/\r/g,'').split(/[\n,]+/).map(s=>s.trim()).filter(Boolean);
      const out=[];
      for(const p of parts){
        const m = p.match(/^(.+?)\s*\*\s*(\d+)$/);
        if(m){
          const name=m[1].trim();
          const n=clamp(parseInt(m[2],10)||1,1,999);
          for(let i=0;i<n;i++) out.push(name);
        }else out.push(p);
      }
      return out.slice(0, 200);
    }

    // ---------- world dims ----------
    const W=780;
    const VIEW_H=940;
    const WORLD_H=5900;
    const WALL=26;

    const Z1={y0:140,  y1:1750};
    const Z2={y0:1750, y1:3400};
    const Z3={y0:3400, y1:4500};
    const Z4={y0:4500, y1:5300};
    const ZF={y0:5300, y1:5780};

    class Main extends Phaser.Scene {
      constructor(){ super('main'); }
      init(data){
        this.cfg=data.cfg;
        this.rng=mulberry32(this.cfg.seed|0);
        this.balls=[];
        this.labels=[];
        this.total=0; this.finished=0;
        this.startAt=0;
        this.finalEventFired=false;
        this.gravityEventDone=false;
        this.camMode=0; // 0 AVG, 1 LEAD, 2 LAST, 3 CHAOS
        this.trailG=null;
        this.minimap=null;
        this.autoZoom = !!this.cfg.autoZoom;
      }

      create(){
        // physics: punchy
        this.matter.world.setBounds(0,0,W,WORLD_H,64,true,true,false,true);
        this.matter.world.engine.positionIterations=10;
        this.matter.world.engine.velocityIterations=8;
        this.matter.world.setGravity(0,1.12);

        // IMPORTANT: keep balls from "vanishing" by sleeping too hard
        this.matter.world.engine.enableSleeping = true;

        // camera
        this.cameras.main.setBounds(0,0,W,WORLD_H);
        this.cameras.main.setViewport(0,0,window.innerWidth,window.innerHeight);
        this.cameras.main.setZoom(1.12);

        this.scale.on('resize', (gs)=>{
          this.cameras.main.setViewport(0,0,gs.width,gs.height);
          if (this.minimap){
            this.minimap.setPosition(gs.width - 220, 14);
          }
        });

        // key binds
        this.input.keyboard.on('keydown-C', ()=>{
          this.camMode = (this.camMode+1)%4;
          this._announce('CAM: ' + ['AVG','LEAD','LAST','CHAOS'][this.camMode]);
        });
        this.input.keyboard.on('keydown-Z', ()=>{
          this.autoZoom = !this.autoZoom;
          this._announce('ZOOM: ' + (this.autoZoom ? 'AUTO' : 'LOCK'));
        });

        // background
        this._drawNeonBG();

        // build map (with spinner + blackholes etc)
        this._buildTrackV3();

        // spawn balls
        this._spawnPlayers();

        // finish sensor
        this.finish = this.matter.add.rectangle(W/2, WORLD_H-92, W-2*WALL-80, 18, {isStatic:true,isSensor:true,label:'finish'});
        this._neonRect(W/2, WORLD_H-92, W-2*WALL-80, 18, 0x2cff9a, 0.18, 2.2);

        this.matter.world.on('collisionstart', (evt)=>{
          for(const pair of evt.pairs){
            const a=pair.bodyA, b=pair.bodyB;
            if ((a.label==='finish' && b.label==='ball') || (b.label==='finish' && a.label==='ball')){
              const ballBody = (a.label==='ball')?a:b;
              const s = ballBody.gameObject;
              if(s && !s._done){
                s._done=true;
                this.finished++;
                // freeze & fade a bit (NOT vanish)
                s.setStatic(true);
                this.tweens.add({targets:s, alpha:0.35, duration:240});
              }
            }
          }
        });

        // minimap (top-right)
        this.minimap = this.cameras.add(window.innerWidth - 220, 14, 200, 280)
          .setZoom(0.08)
          .setBounds(0,0,W,WORLD_H)
          .setBackgroundColor(0x000000)
          .setAlpha(0.78);
        // minimap should not follow main camera
        this.minimap.scrollX = 0;
        this.minimap.scrollY = 0;

        // trail graphics
        this.trailG = this.add.graphics().setDepth(-2);

        this.startAt = performance.now();

        // HUD timer
        this.time.addEvent({delay:120, loop:true, callback:()=>this._updateHUD()});

        // bombs every 2s near current view (so ALWAYS visible)
        this.time.addEvent({
          delay: 2000, loop:true, callback:()=>{
            const y = this.cameras.main.scrollY + 520 + this.rng()*260;
            const x = WALL+120 + this.rng()*(W-2*WALL-240);
            this._bombShockwave(x,y);
          }
        });

        // final event once (moderate, not always flip)
        this.time.addEvent({
          delay:250, loop:true, callback:()=>{
            const t = (performance.now()-this.startAt)/1000;

            // gravity wiggle (rare)
            if(!this.gravityEventDone && t>46){
              this.gravityEventDone=true;
              if(this.rng()<0.22){
                const dir=this.rng()<0.5?-1:1;
                this._announce('EVENT: GRAV WIGGLE');
                this.matter.world.setGravity(0.55*dir, 0.92);
                this.time.delayedCall(1800, ()=>this.matter.world.setGravity(0,1.12));
              }
            }

            if(!this.finalEventFired && t>55){
              const near = this.balls.some(s=>!s._done && s.y>ZF.y0-260);
              if(near) this._finalEvent();
            }
          }
        });
      }

      update(){
        // safety respawn for "vanish" cases
        for(const s of this.balls){
          if(s._done) continue;
          if (s.y > WORLD_H + 240 || s.x < -240 || s.x > W + 240){
            const b=s.body;
            const tx = WALL+90 + this.rng()*(W-2*WALL-180);
            const ty = Z4.y0 + 220 + this.rng()*240;
            this.matter.body.setPosition(b,{x:tx,y:ty});
            this.matter.body.setVelocity(b,{x:(this.rng()-0.5)*2, y:1});
          }
        }

        // camera follow by mode
        const alive = this.balls.filter(s=>!s._done);
        if (alive.length){
          let targetY;

          if (this.camMode===1){ // LEAD
            alive.sort((a,b)=>b.y-a.y);
            targetY = alive[0].y - VIEW_H*0.35;
          } else if (this.camMode===2){ // LAST
            alive.sort((a,b)=>a.y-b.y);
            targetY = alive[0].y - VIEW_H*0.35;
          } else if (this.camMode===3){ // CHAOS: densest bucket
            const buckets=new Map();
            for(const s of alive){
              const key=Math.floor(s.y/260);
              buckets.set(key,(buckets.get(key)||0)+1);
            }
            let bestK=0, bestC=-1;
            for(const [k,c] of buckets.entries()){
              if(c>bestC){bestC=c;bestK=k;}
            }
            targetY = bestK*260 - VIEW_H*0.25;
          } else { // AVG
            const avg = alive.reduce((sum,s)=>sum+s.y,0)/alive.length;
            targetY = avg - VIEW_H*0.38;
          }

          targetY = clamp(targetY, 0, WORLD_H - VIEW_H);
          this.cameras.main.scrollY = Phaser.Math.Linear(this.cameras.main.scrollY, targetY, 0.10);

          if(this.autoZoom){
            const ys = alive.map(s=>s.y);
            const spread = Math.max(...ys) - Math.min(...ys);
            const zoom = clamp(1.25 - (spread/1800), 0.85, 1.25);
            this.cameras.main.setZoom(Phaser.Math.Linear(this.cameras.main.zoom, zoom, 0.06));
          }
        }

        // trails (NEON visibility)
        this.trailG.clear();
        for(const s of this.balls){
          if(s._done) continue;
          if(!s._trail) s._trail=[];
          s._trail.push({x:s.x,y:s.y});
          if(s._trail.length>14) s._trail.shift();

          const col = s.fillColor ?? 0xffffff;
          for(let i=1;i<s._trail.length;i++){
            const a=s._trail[i-1], b=s._trail[i];
            const alpha = (i/s._trail.length)*0.32;
            this.trailG.lineStyle(5, col, alpha);
            this.trailG.beginPath();
            this.trailG.moveTo(a.x,a.y);
            this.trailG.lineTo(b.x,b.y);
            this.trailG.strokePath();
          }
        }

        // label follow
        if(this.cfg.showNames){
          for(let i=0;i<this.balls.length;i++){
            const s=this.balls[i], t=this.labels[i];
            if(!t) continue;
            t.setPosition(s.x, s.y - s.displayHeight*0.85);
            t.setVisible(!s._done);
          }
        }
      }

      // ---------- visuals ----------
      _drawNeonBG(){
        const g=this.add.graphics().setDepth(-30);
        g.lineStyle(1, 0x1f284a, 0.30);
        for(let y=0;y<=WORLD_H;y+=92){ g.beginPath(); g.moveTo(0,y); g.lineTo(W,y); g.strokePath(); }
        for(let x=0;x<=W;x+=92){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,WORLD_H); g.strokePath(); }
      }

      _neonRect(x,y,w,h,color,fillAlpha=0.06, glow=2.0, angle=0){
        const r=this.add.rectangle(x,y,w,h,color,fillAlpha).setDepth(-10);
        r.setRotation(angle);
        r.setStrokeStyle(3,color,0.88);
        const g1=this.add.rectangle(x,y,w,h,color,0).setDepth(-11);
        g1.setRotation(angle); g1.setStrokeStyle(10,color,0.12*glow);
        const g2=this.add.rectangle(x,y,w,h,color,0).setDepth(-12);
        g2.setRotation(angle); g2.setStrokeStyle(20,color,0.06*glow);
      }

      _staticWall(x,y,w,h,color=0x8efcff, angle=0){
        const body=this.matter.add.rectangle(x,y,w,h,{isStatic:true,restitution:1.14,friction:0.001,angle,label:'wall'});
        this._neonRect(x,y,w,h,color,0.02,2.5,angle);
        return body;
      }

      _bumper(x,y,r,color=0xffd84a){
        this.matter.add.circle(x,y,r,{isStatic:true,restitution:1.38,friction:0.0008,label:'bumper'});
        this.add.circle(x,y,r,color,0.08).setStrokeStyle(3,color,0.85).setDepth(-9);
        this.add.circle(x,y,r+12,color,0.02).setDepth(-12);

        const sensor=this.matter.add.circle(x,y,r+16,{isStatic:true,isSensor:true,label:'bumperS'});
        this.matter.world.on('collisionstart',(evt)=>{
          for(const p of evt.pairs){
            const a=p.bodyA,b=p.bodyB;
            if ((a===sensor && b.label==='ball') || (b===sensor && a.label==='ball')){
              const ball=(b.label==='ball')?b:a;
              const dx=ball.position.x-x, dy=ball.position.y-y;
              const d=Math.max(1,Math.hypot(dx,dy));
              const k=0.0019;
              ball.force.x += (dx/d)*k*150;
              ball.force.y += (dy/d)*k*150;
            }
          }
        });
      }

      _addSpinnerBar(x,y,len=260,th=18, speed=0.012){
        const bar=this.matter.add.rectangle(x,y,len,th,{isStatic:true,restitution:1.25,friction:0.001,label:'spinner'});
        this._neonRect(x,y,len,th,0x00ffff,0.02,2.9,0);

        this.time.addEvent({
          delay:16, loop:true, callback:()=>{ this.matter.body.rotate(bar, speed); }
        });
      }

      _rotor(x,y,r,dir=1){
        this.matter.add.circle(x,y,r,{isStatic:true,restitution:1.15,friction:0.001,label:'rotor'});
        const col=0x7cfffb;
        this.add.circle(x,y,r,col,0.05).setStrokeStyle(3,col,0.75).setDepth(-9);
        this.add.circle(x,y,r+12,col,0.02).setDepth(-12);
        const sensor=this.matter.add.circle(x,y,r+28,{isStatic:true,isSensor:true,label:'rotorS'});
        this.matter.world.on('collisionstart',(evt)=>{
          for(const p of evt.pairs){
            const a=p.bodyA,b=p.bodyB;
            if ((a===sensor && b.label==='ball') || (b===sensor && a.label==='ball')){
              const ball=(b.label==='ball')?b:a;
              const dx=ball.position.x-x, dy=ball.position.y-y;
              const d=Math.max(1,Math.hypot(dx,dy));
              const tx = -dy/d * dir;
              const ty =  dx/d * dir;
              const k=0.0011;
              ball.force.x += tx*k*130;
              ball.force.y += ty*k*130;
            }
          }
        });
      }

      _blackHole(x,y,r){
        const col=0xb38bff;
        this.matter.add.circle(x,y,r,{isStatic:true,isSensor:true,label:'hole'});
        this.add.circle(x,y,r,0x000000,0.32).setStrokeStyle(3,col,0.55).setDepth(-9);
        this.add.circle(x,y,r+14,col,0.02).setDepth(-12);

        // pull
        this.time.addEvent({
          delay:16, loop:true, callback:()=>{
            for(const s of this.balls){
              if(s._done) continue;
              const b=s.body;
              const dx=x-b.position.x, dy=y-b.position.y;
              const d=Math.hypot(dx,dy);
              if(d<r*2.2){
                const k=(1-d/(r*2.2))*0.00060;
                b.force.x += (dx/d)*k*150;
                b.force.y += (dy/d)*k*150;
              }
            }
          }
        });

        // swallow -> warp (VISIBLE effect, not delete)
        this.time.addEvent({
          delay:90, loop:true, callback:()=>{
            for(const s of this.balls){
              if(s._done) continue;
              const b=s.body;
              const d=Math.hypot(x-b.position.x, y-b.position.y);
              if(d<r*0.42){
                this._warpEffect(b.position.x, b.position.y);
                const tx=WALL+100 + this.rng()*(W-2*WALL-200);
                const ty=Z3.y0+180 + this.rng()*(Z3.y1-Z3.y0-360);
                this.matter.body.setPosition(b,{x:tx,y:ty});
                this.matter.body.setVelocity(b,{x:(this.rng()-0.5)*4, y:(this.rng()-0.5)*2});
                this._warpEffect(tx,ty);
              }
            }
          }
        });
      }

      _warpEffect(x,y){
        const g=this.add.graphics().setDepth(60);
        const col=0xb38bff;
        let r=10, a=0.7;
        const id=this.time.addEvent({
          delay:16, repeat:18, callback:()=>{
            g.clear();
            g.lineStyle(6,col,a);
            g.strokeCircle(x,y,r);
            r+=10; a*=0.90;
          },
          callbackScope:this,
          onComplete:()=>{ g.destroy(); }
        });
      }

      _announce(msg){
        const t=this.add.text(W/2, this.cameras.main.scrollY + 90, msg, {
          fontSize:'20px', fontStyle:'900', color:'#ffffff',
          stroke:'#000000', strokeThickness:6
        }).setOrigin(0.5).setAlpha(0).setDepth(80);
        this.tweens.add({targets:t, alpha:1, duration:170, yoyo:true, hold:900, onComplete:()=>t.destroy()});
      }

      // ---------- map ----------
      _buildTrackV3(){
        // side walls neon
        this._staticWall(WALL/2, WORLD_H/2, WALL, WORLD_H, 0x8efcff);
        this._staticWall(W - WALL/2, WORLD_H/2, WALL, WORLD_H, 0x8efcff);

        const chaos=this.cfg.chaos;

        // Zone 1: dense bumpers + deflectors
        const cols=9, rows=15 + chaos*2;
        const xMin=WALL+70, xMax=W-WALL-70;
        const yMin=Z1.y0+140, yMax=Z1.y1-110;

        for(let r=0;r<rows;r++){
          const y = Phaser.Math.Linear(yMin,yMax, r/(rows-1));
          for(let c=0;c<cols;c++){
            const x = Phaser.Math.Linear(xMin,xMax, c/(cols-1)) + ((r%2)*18) + (this.rng()-0.5)*10;
            if(this.rng()<0.82) this._bumper(x,y, 10+this.rng()*6, 0xffd84a);
          }
        }
        for(let i=0;i<10+chaos*2;i++){
          const x=xMin+this.rng()*(xMax-xMin);
          const y=yMin+this.rng()*(yMax-yMin);
          const w=150+this.rng()*110;
          const h=18;
          const ang=(this.rng()<0.5?-1:1)*(0.22+this.rng()*0.55);
          this.matter.add.rectangle(x,y,w,h,{isStatic:true,restitution:1.18,friction:0.001,angle:ang,label:'def'});
          this._neonRect(x,y,w,h,0x7cfffb,0.02,2.2,ang);
        }

        // Zone 2: branch lanes + moving gates + spinner bars
        const laneW=(W-2*WALL-40)/3;
        const y0=Z2.y0+70, y1=Z2.y1-70;

        for(let i=1;i<=2;i++){
          this._staticWall(WALL+20 + laneW*i, (y0+y1)/2, 12, (y1-y0), 0x6f7cff);
        }

        // moving gates
        for(let i=0;i<7+chaos;i++){
          const lane=Math.floor(this.rng()*3);
          const x=WALL+20 + laneW*lane + laneW/2;
          const y=y0 + this.rng()*(y1-y0);
          const w=laneW*0.70, h=18;
          const dx=90+this.rng()*70;
          const period=850+this.rng()*650;
          const body=this.matter.add.rectangle(x,y,w,h,{isStatic:true,restitution:1.12,friction:0.001,label:'gate'});
          // moving neon rect (so you can SEE it)
          const rect=this.add.rectangle(x,y,w,h,0xff6bd6,0.05).setStrokeStyle(3,0xff6bd6,0.85).setDepth(-9);
          const glow1=this.add.rectangle(x,y,w,h,0xff6bd6,0).setStrokeStyle(12,0xff6bd6,0.12).setDepth(-11);
          const glow2=this.add.rectangle(x,y,w,h,0xff6bd6,0).setStrokeStyle(24,0xff6bd6,0.06).setDepth(-12);

          const t0p=performance.now();
          this.time.addEvent({
            delay:16, loop:true, callback:()=>{
              const t=(performance.now()-t0p)/period*Math.PI*2;
              const nx=x + Math.sin(t)*dx;
              this.matter.body.setPosition(body,{x:nx,y:y});
              rect.setPosition(nx,y); glow1.setPosition(nx,y); glow2.setPosition(nx,y);
            }
          });
        }

        // spinners (visible chaos)
        this._addSpinnerBar(W*0.30, Z2.y0+620, 280, 18, 0.015);
        this._addSpinnerBar(W*0.70, Z2.y0+980, 260, 18, -0.014);
        this._addSpinnerBar(W*0.50, Z2.y0+1380, 300, 18, 0.016);

        for(let i=0;i<24+chaos*5;i++){
          const x=WALL+70+this.rng()*(W-2*WALL-140);
          const y=y0+this.rng()*(y1-y0);
          this._bumper(x,y, 10+this.rng()*6, 0x2cff9a);
        }

        // Zone 3: rotors + pin forest
        const yMid=(Z3.y0+Z3.y1)/2;
        this._rotor(W/2, yMid, 66, this.rng()<0.5?1:-1);
        this._rotor(W*0.28, yMid-280, 52, 1);
        this._rotor(W*0.72, yMid+270, 52, -1);

        for(let i=0;i<80+chaos*12;i++){
          const x=WALL+70+this.rng()*(W-2*WALL-140);
          const y=Z3.y0+140+this.rng()*(Z3.y1-Z3.y0-280);
          this._bumper(x,y, 9+this.rng()*5, 0xffd84a);
        }

        // Zone 4: blackholes (2~3)
        const holes = (chaos>=3) ? 3 : 2;
        for(let i=0;i<holes;i++){
          const x=WALL+160+this.rng()*(W-2*WALL-320);
          const y=Z4.y0+160+this.rng()*(Z4.y1-Z4.y0-320);
          this._blackHole(x,y, 56+this.rng()*14);
        }

        // Final: corridor + bumpers
        const fy0=ZF.y0+50, fy1=ZF.y1-170;
        this._staticWall(WALL+98, (fy0+fy1)/2, 14, (fy1-fy0), 0x2cff9a);
        this._staticWall(W-(WALL+98), (fy0+fy1)/2, 14, (fy1-fy0), 0x2cff9a);
        for(let i=0;i<20+chaos*3;i++){
          const x=WALL+130+this.rng()*(W-2*WALL-260);
          const y=fy0+this.rng()*(fy1-fy0);
          this._bumper(x,y, 10+this.rng()*6, 0x7cfffb);
        }
      }

      // ---------- spawn ----------
      _pickBallCount(maxBalls){
        if(!this.cfg.rndBalls) return maxBalls;
        const r=this.rng();
        if(maxBalls<=1) return 1;
        if(maxBalls===2) return (r<0.55)?1:2;
        if(r<0.45) return 1;
        if(r<0.80) return 2;
        return 3;
      }
      _pickBallType(){
        if(!this.cfg.rndSize) return {radius:14,density:0.0022,restitution:1.23};
        const c=this.cfg.chaos;
        const r=this.rng();
        const giant=0.02 + c*0.01;
        const large=0.20 + c*0.03;
        const small=0.25 + c*0.02;
        if(r<giant) return {radius:23,density:0.0039,restitution:1.06};
        if(r<giant+large) return {radius:18,density:0.0031,restitution:1.10};
        if(r<giant+large+small) return {radius:12,density:0.0018,restitution:1.31};
        return {radius:14,density:0.0022,restitution:1.23};
      }

      _spawnPlayers(){
        const maxPlayers=clamp(this.cfg.maxPlayers,2,20);
        let pool = (this.cfg.names && this.cfg.names.length) ? this.cfg.names.slice() : Array.from({length:maxPlayers},(_,i)=>`P${i+1}`);

        // choose subset if random players
        let chosen = pool.slice(0, maxPlayers);
        if(this.cfg.rndPlayers && pool.length>2){
          const size = 2 + Math.floor(this.rng()*(maxPlayers-1));
          // shuffle
          for(let i=pool.length-1;i>0;i--){
            const j=Math.floor(this.rng()*(i+1));
            [pool[i],pool[j]]=[pool[j],pool[i]];
          }
          chosen = pool.slice(0, size);
        } else {
          chosen = chosen.slice(0, maxPlayers);
        }

        const colors=[
          0x7cfffb,0xff6bd6,0xffd84a,0x2cff9a,0xb38bff,0xff8a4a,0x6f7cff,
          0xff4d6d,0x4dff88,0x4d7dff,0xfff04d,0x8a4dff,0x4dfff0,0xff4df0,
          0xaaff4d,0x4dffaa,0xffaa4d,0xaa4dff,0x4daaff,0xffffff
        ];

        const startY=80;
        const span=W-2*WALL-180;

        for(let i=0;i<chosen.length;i++){
          const count=this._pickBallCount(clamp(this.cfg.maxBalls,1,3));
          for(let k=0;k<count;k++){
            const t=this._pickBallType();
            const x=WALL+90 + (i/Math.max(1,chosen.length-1))*span + (this.rng()-0.5)*22 + (k-0.5)*10;
            const y=startY - k*22;
            const col=colors[i%colors.length];

            const ball=this.add.circle(x,y,t.radius,col,0.22).setStrokeStyle(3,col,0.88);
            this.matter.add.gameObject(ball,{
              shape:{type:'circle',radius:t.radius},
              label:'ball',
              friction:0.002,
              frictionAir:0.003,
              restitution:t.restitution,
              density:t.density
            });
            ball.setVelocity((this.rng()-0.5)*2.2, 0.6+this.rng()*0.7);
            ball._done=false;
            ball._name=chosen[i];
            ball._trail=[];

            let txt=null;
            if(this.cfg.showNames){
              txt=this.add.text(x,y,chosen[i],{
                fontSize:'16px',fontStyle:'900',color:'#ffffff',
                stroke:'#000000',strokeThickness:6
              }).setOrigin(0.5,1).setDepth(40);
            }
            this.balls.push(ball);
            this.labels.push(txt);
          }
        }

        this.total=this.balls.length;
      }

      // ---------- bombs & events ----------
      _bombShockwave(x,y){
        // particle burst
        const p=this.add.particles(0xffffff).setDepth(70);
        p.createEmitter({
          x,y,
          speed:{min:90,max:360},
          angle:{min:0,max:360},
          lifespan:520,
          quantity:28,
          scale:{start:0.7,end:0},
          alpha:{start:0.85,end:0}
        });
        this.time.delayedCall(260, ()=>p.destroy());

        // ring
        const g=this.add.graphics().setDepth(71);
        let r=10, a=0.65;
        this.time.addEvent({
          delay:16, repeat:18, callback:()=>{
            g.clear();
            g.lineStyle(8,0xff6bd6,a);
            g.strokeCircle(x,y,r);
            r+=16; a*=0.90;
          },
          onComplete:()=>g.destroy()
        });

        // shockwave physics
        for(const s of this.balls){
          if(s._done) continue;
          const b=s.body;
          const dx=b.position.x-x, dy=b.position.y-y;
          const d=Math.max(40, Math.hypot(dx,dy));
          if(d<340){
            const k=(1 - d/340)*0.0026;
            b.force.x += (dx/d)*k*280;
            b.force.y += (dy/d)*k*260;
          }
        }
      }

      _finalEvent(){
        this.finalEventFired=true;
        const roll=this.rng();
        let msg='FINAL: (NO EVENT)';
        if(roll<0.40){
          // none
        }else if(roll<0.65){
          msg='FINAL: ACCEL';
          this.matter.world.setGravity(0,1.30);
          this.time.delayedCall(2200, ()=>this.matter.world.setGravity(0,1.12));
        }else if(roll<0.80){
          msg='FINAL: SHOCKWAVE';
          const cx=W/2, cy=ZF.y0+240;
          this._bombShockwave(cx,cy);
        }else if(roll<0.90){
          msg='FINAL: SWAP(2)';
          const cand=this.balls.filter(s=>!s._done && s.y>ZF.y0-160 && s.y<ZF.y1-80);
          if(cand.length>=2){
            const a=cand[Math.floor(this.rng()*cand.length)];
            let b=cand[Math.floor(this.rng()*cand.length)];
            if(a===b) b=cand[(cand.indexOf(a)+1)%cand.length];
            const pa={x:a.body.position.x,y:a.body.position.y};
            const pb={x:b.body.position.x,y:b.body.position.y};
            this._warpEffect(pa.x,pa.y);
            this._warpEffect(pb.x,pb.y);
            this.matter.body.setPosition(a.body,pb);
            this.matter.body.setPosition(b.body,pa);
            this._warpEffect(pb.x,pb.y);
            this._warpEffect(pa.x,pa.y);
          } else {
            msg='FINAL: (SWAP FAIL)';
          }
        }else{
          msg='FINAL: STICKY';
          for(const s of this.balls){
            if(!s._done && s.y>ZF.y0-260 && s.y<ZF.y1) s.setFrictionAir(0.022);
          }
          this.time.delayedCall(2000, ()=>{
            for(const s of this.balls){ if(!s._done) s.setFrictionAir(0.003); }
          });
        }
        this._announce(msg);
      }

      _updateHUD(){
        const t=(performance.now()-this.startAt)/1000;
        const alive=this.total-this.finished;
        const hud=document.getElementById('hud');
        const mini=document.getElementById('miniHud');

        const ongoing=this.balls.filter(s=>!s._done).sort((a,b)=>b.y-a.y);
        const top=ongoing.slice(0,10).map(s=>s._name).join(', ');

        const mode=['AVG','LEAD','LAST','CHAOS'][this.camMode];

        const text =
          `ì§„í–‰: <b>${this.finished}</b> / ${this.total} (ë‚¨ìŒ ${alive})<br>`+
          `ê²½ê³¼: ${t.toFixed(1)}s Â· CAM: <b>${mode}</b> Â· ZOOM: ${this.autoZoom?'AUTO':'LOCK'}<br>`+
          `ì„ ë‘ê¶Œ: ${top || 'â€”'}<br>`+
          `FINAL: ${this.finalEventFired?'ë°œë™ë¨':'ëŒ€ê¸°ì¤‘'} Â· í­íƒ„: 2.0s`;

        hud.innerHTML=text;
        mini.textContent = `ì§„í–‰ ${this.finished}/${this.total} Â· ${t.toFixed(1)}s Â· ${mode}`;
      }
    }

    // ---------- boot ----------
    let game=null;

    function getCfg(){
      return {
        names: parseNames(document.getElementById('names').value),
        maxPlayers: parseInt(document.getElementById('maxPlayers').value,10)||20,
        maxBalls: parseInt(document.getElementById('maxBalls').value,10)||2,
        chaos: clamp(parseInt(document.getElementById('chaos').value,10)||3,0,5),
        seed: parseInt(document.getElementById('seed').value,10)||12345,
        rndPlayers: document.getElementById('rndPlayers').checked,
        rndBalls: document.getElementById('rndBalls').checked,
        rndSize: document.getElementById('rndSize').checked,
        showNames: document.getElementById('showNames').checked,
        autoZoom: document.getElementById('autoZoom').checked
      };
    }

    function start(){
      const cfg=getCfg();
      if(game){ game.destroy(true); game=null; }
      game=new Phaser.Game({
        type: Phaser.AUTO,
        backgroundColor:'#05060b',
        width: window.innerWidth,
        height: window.innerHeight,
        physics:{
          default:'matter',
          matter:{ gravity:{y:1.12}, enableSleep:true, debug:false }
        },
        scene:[ new Main() ]
      });
      game.scene.start('main',{cfg});
    }

    function newSeed(){
      document.getElementById('seed').value = 1 + Math.floor(Math.random()*999999);
    }

    const panel=document.getElementById('panel');
    const mini=document.getElementById('mini');
    document.getElementById('toggleBtn').onclick=()=>{ panel.style.display='none'; mini.style.display='block'; };
    document.getElementById('openBtn').onclick=()=>{ panel.style.display='block'; mini.style.display='none'; };

    document.getElementById('startBtn').onclick=start;
    document.getElementById('startBtn2').onclick=start;
    document.getElementById('seedBtn').onclick=newSeed;

    start();
  </script>
</body>
</html>
